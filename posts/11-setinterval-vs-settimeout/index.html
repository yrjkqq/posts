<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>setTimeout 和 setInterval - That's the Way It Is</title><link rel=icon type=image/png href=/posts/img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:description" content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><meta name=twitter:description content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><meta name=description content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><meta name=description content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><meta property="og:title" content="setTimeout 和 setInterval | That's the Way It Is"><meta name=twitter:title content="setTimeout 和 setInterval | That's the Way It Is"><meta property="og:image" content><meta itemprop=name content="setTimeout 和 setInterval | That's the Way It Is"><meta name=application-name content="setTimeout 和 setInterval | That's the Way It Is"><meta property="og:site_name" content><meta property="og:title" content="setTimeout 和 setInterval"><meta property="og:description" content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><meta property="og:type" content="article"><meta property="og:url" content="https://yrjkqq.github.io/posts/posts/11-setinterval-vs-settimeout/"><meta property="article:published_time" content="2020-11-19T01:50:00+08:00"><meta property="article:modified_time" content="2020-11-19T01:50:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="setTimeout 和 setInterval"><meta name=twitter:description content="比较 setTimeout 和 setInterval 的使用差异和各自使用场景"><link href=https://yrjkqq.github.io/posts/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://yrjkqq.github.io/posts/css/main.css><link rel=stylesheet type=text/css href=https://yrjkqq.github.io/posts/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://yrjkqq.github.io/posts/>That's the Way It Is</a></div><nav><a href=/posts/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>setTimeout 和 setInterval</h1><div class=meta>Posted on Nov 19, 2020</div></div><section class=body><p>JavaScript 如何模拟 sleep 的函数效果？</p><p>在 es5 中可以使用 while(){} 循环，循环条件为当前时间戳与循环开始前时间戳的的差值，如果小于 sleep 的时间间隔，则继续循环，以此模拟。</p><p>而在 es6 中可以借助 async await 的语法更优雅且高效的实现这一效果，代码参考 <a href=https://stackoverflow.com/a/39914235/12796820>stack overflow</a> 如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#a6e22e>time</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>) =&gt; <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>time</span>));
}

<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wait</span>() {
  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#ae81ff>2000</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;2 seconds later&#34;</span>)
}
</code></pre></div><p>有了 sleep 函数之后可以验证 setTimeout 和 setInterval 的具体执行效果。查找资料 <a href=https://javascript.info/settimeout-setinterval#nested-settimeout>Scheduling: setTimeout and setInterval</a> 发现：在使用 setInterval 的过程中，会发现前后两次函数的执行时间间隔（上一次执行完成到下一次调用开始）并不是精确的等于指定的延迟时间，是因为 setInterval 是由 JavaScript 引擎进行调度的，每隔指定的延迟时间就会执行回调函数。引擎会等待回调函数执行完成，然后检查调度器如果时间到了指定的延迟时间，则立即执行下一次调用。而回调函数本身执行需要一定时间，这个时间是计算在指定的延迟时间内的，所以前一次调用结束到下一次调用开始的时间间隔是小于指定的延迟时间的。但是，如果函数执行的时间超过了延迟时间，那么下一次调用会立即开始，这种情况下实际的延迟时间会大于执行的延迟时间。</p><p>同时在 setInterval 使用前述的 sleep 函数是没有效果的，代码如下。会依次打印 2 2 5 2 5 &mldr;, 其中一开始连续打印两个 2 后才开始打印 5，由此可见 sleep 实际上还是在上一次调度中，结束后打印 5，而此时第三次调度已经开始了。setInterval 的调度并没有等待 sleep 的完成。推测是由于引擎的调度形式有关，会严格按照指定延迟进行调度，而不会将函数执行时间计算在调度内（前文资料中的说法不准确，下一次调用不会等待上一次回调完成，调度器检测到延迟时间已到则会立即开始下一次），所以如果函数本身执行时间大于延迟时间，那么就会出现上一次调用没完成，下一次已经开始了。如果是在发送请求的场景中，可能会造成服务器无法及时响应而请求还在不断累积的现象，超负载。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>last</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#a6e22e>time</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>) =&gt; <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>time</span>));
}

<span style=color:#a6e22e>setInterval</span>(<span style=color:#66d9ef>async</span> () =&gt; {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;2&#34;</span>);
  <span style=color:#a6e22e>last</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span>;
  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#ae81ff>3000</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;5&#34;</span>);
}, <span style=color:#ae81ff>2000</span>);

<span style=color:#75715e>// 2 2 5 2 5 
</span></code></pre></div><p>为了避免出现函数执行时间超过延迟时间导致调用积压，需要精确的控制两次函数的执行间隔，上一次调用完成后必须等待指定时间才能开始下一次延迟。递归式的调用 setTimeout 可以实现。代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>last</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#a6e22e>time</span>) {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>) =&gt; <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>time</span>));
}

<span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>wait</span>() {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>now</span> <span style=color:#f92672>=</span> Date.<span style=color:#a6e22e>now</span>();
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;2&#34;</span>);
  <span style=color:#a6e22e>last</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>now</span>;
  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>sleep</span>(<span style=color:#ae81ff>3000</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;5&#34;</span>);
  <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>wait</span>, <span style=color:#ae81ff>2000</span>);
}, <span style=color:#ae81ff>2000</span>);
<span style=color:#75715e>// 2 5 2 5 ...
</span></code></pre></div><p>2 秒后打印2，sleep 3 秒后打印 5，然后开始下一次调用。时间间隔恰好是 2 秒，而 sleep 函数也可以生效。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/posts/tags/javascript>JavaScript</a></li></ul></nav></div></article></main><footer><hr>⚡️
2020 © yrjkqq | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>