<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>ES2015 标准化的 promise - That's the Way It Is</title><link rel=icon type=image/png href=/posts/img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:description" content="学习 Promise 的用法和相关"><meta name=twitter:description content="学习 Promise 的用法和相关"><meta name=description content="学习 Promise 的用法和相关"><meta name=description content="学习 Promise 的用法和相关"><meta property="og:title" content="ES2015 标准化的 promise | That's the Way It Is"><meta name=twitter:title content="ES2015 标准化的 promise | That's the Way It Is"><meta property="og:image" content><meta itemprop=name content="ES2015 标准化的 promise | That's the Way It Is"><meta name=application-name content="ES2015 标准化的 promise | That's the Way It Is"><meta property="og:site_name" content><meta property="og:title" content="ES2015 标准化的 promise"><meta property="og:description" content="学习 Promise 的用法和相关"><meta property="og:type" content="article"><meta property="og:url" content="https://yrjkqq.github.io/posts/posts/04-promise/"><meta property="article:published_time" content="2018-09-08T19:41:00+08:00"><meta property="article:modified_time" content="2018-09-08T19:41:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ES2015 标准化的 promise"><meta name=twitter:description content="学习 Promise 的用法和相关"><link href=https://yrjkqq.github.io/posts/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://yrjkqq.github.io/posts/css/main.css><link rel=stylesheet type=text/css href=https://yrjkqq.github.io/posts/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://yrjkqq.github.io/posts/>That's the Way It Is</a></div><nav><a href=/posts/tags>Tags</a>
<a href=/posts/posts>All</a></nav></header><main><article><div class=title><h1 class=title>ES2015 标准化的 promise</h1><div class=meta>Posted on Sep 8, 2018</div></div><section class=body><p>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。</p><p>Promise 新建后就会立即执行。</p><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。如果调用 resolve 和 reject 时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数可以是正常值，也可以是另一个 Promise 实例。</p><p>调用 resolve 函数后面的代码也会执行，并且会先于 Promise 实例的 then 回调函数执行。因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
  <span style=color:#a6e22e>resolve</span>(<span style=color:#ae81ff>1</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#ae81ff>2</span>);
}).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>r</span> =&gt; {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>r</span>);
});
<span style=color:#75715e>// 2
</span><span style=color:#75715e>// 1
</span></code></pre></div><p>then 方法指定的回调函数在运行中抛出错误，也会被气候的 catch() 方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。</p><p>最佳实践：不要在 then() 方法定义 Reject 状态的回调函数，总是使用 catch 方法。</p><p>如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，<em>Promise 会吃掉错误。</em> 在服务端可以使用 <code>process.on("unhandledRejection", callback)</code> 来捕获到这种错误。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>someAsyncThing</span> <span style=color:#f92672>=</span> () =&gt; {
  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
    <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
  });
};

<span style=color:#a6e22e>someAsyncThing</span>().<span style=color:#a6e22e>then</span>(() =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;ok&#34;</span>));

<span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;after 2 seconds&#34;</span>), <span style=color:#ae81ff>2000</span>);

<span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;unhandledRejection&#34;</span>, (<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>p</span>) =&gt; {
  <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>err</span>;
});
</code></pre></div><p>Promise 内部指定在下一轮事件循环再抛出错误。而到下一轮事件循环时，Promise 的运行已经结束了，所以抛出的错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误，导致程序异常退出。如果改写成 <code>reject(new Error('error'))</code> 则会被 catch 捕获到。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>promise</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
  <span style=color:#75715e>// resolve(&#34;ok&#34;);
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>setTimeout</span>(() =&gt; {
    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#34;error&#34;</span>);
    <span style=color:#75715e>// reject(new Error(&#34;error&#34;));
</span><span style=color:#75715e></span>  }, <span style=color:#ae81ff>0</span>);
  <span style=color:#75715e>// throw new Error(&#34;error&#34;);
</span><span style=color:#75715e></span>});
<span style=color:#a6e22e>promise</span>.<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>v</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>v</span>)).<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>e</span>) =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;e&#34;</span>));
<span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;after 2 seconds&#34;</span>), <span style=color:#ae81ff>2000</span>);

<span style=color:#75715e>// Uncaught Error
</span></code></pre></div><h3 id=promiseprototypefinally>Promise.prototype.finally()</h3><p>ES2018 引入 finally 方法。不管 Promise 对象最后状态如何，都会执行 finally 方法指定的回调函数。</p><h3 id=promiseall>Promise.all()</h3><p><code>Promise.all()</code> 方法用于将多个 Promise 实例包装成一个新的 Promise 实例。只有这多个 Promise 实例状态都变成 fulfilled, Promise.all() 返回的 Promise 实例的状态才会变成 fulfilled.</p><p>all 方法可以结合 for&mldr;of 循环使用，在循环中创建 Promise 实例，发起异步调用，并将该实例保存在数组中，循环完后数组传递给 all 方法，等待所有 promise 完成得到结果。</p><p>如果作为参数的 Promise 实例自己定义了 catch 方法，那么它一旦被 rejected, 并不会触发 Promise.all() 的 catch 方法。因为 rejected 的 Promise 实例被自己的 catch 方法捕获后会返回新的 Promise 实例，该实例执行完 catch 方法后也会变成 resolved 状态。</p><h3 id=promiserace>Promise.race()</h3><p>将多个 Promise 实例包装成新的 Promise 实例。只有多个实例中有一个改变状态，那么新的 Promise 实例状态也会改变。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 如果 5 秒之内 fetch 方法无法返回结果，变量 p 的状态就会变为 rejected，从而触发 catch 方法指定的回调函数。
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> Promise.<span style=color:#a6e22e>race</span>([
  <span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#39;/resource-that-may-take-a-while&#39;</span>),
  <span style=color:#66d9ef>new</span> Promise(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) {
    <span style=color:#a6e22e>setTimeout</span>(() =&gt; <span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;request timeout&#39;</span>)), <span style=color:#ae81ff>5000</span>)
  })
]);

<span style=color:#a6e22e>p</span>
.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>)
.<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>);
</code></pre></div><h3 id=promiseresolve>Promise.resolve()</h3><p>将现有对象转换为 Promise 对象。该方法参数分为四种情况：</p><ol><li><p>参数是一个 Promise 实例<br>不做修改，返回这个实例</p></li><li><p>参数是一个 thenable 对象<br>thenable 对象是指具有 then 方法的对象。Promise.resolve() 方法会将这个对象转为 Promise 对象，然后立即执行 thenable 对象的 then() 方法。转换后的 Promise 实例的 then() 方法可以接收到 thenable 对象执行 then() 方法后传递的参数。</p></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>thenable</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>then</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) {
    <span style=color:#a6e22e>resolve</span>(<span style=color:#ae81ff>42</span>);
  }
};

<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>=</span> Promise.<span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>thenable</span>);
<span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>then</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>value</span>) {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>value</span>);  <span style=color:#75715e>// 42
</span><span style=color:#75715e></span>});
</code></pre></div><ol start=3><li><p>参数没有 then 方法，或者不是对象<br>Promise.resolve() 方法返回一个新的已经 resolved 的 Promise 对象。</p></li><li><p>不带有任何参数<br>直接返回一个 resolved 状态的 Promise 对象。立即 resolve 的 Promise 对象是在本轮事件循环的结束时执行，而不是下一轮事件循环开始时。</p></li></ol><h3 id=promisereject>Promise.reject()</h3><p>返回新的状态为 rejected 的 Promise 实例。</p><h3 id=promisetryhttpses6ruanyifengcomdocspromisepromise-try><a href=https://es6.ruanyifeng.com/#docs/promise#Promise-try>Promise.try()</a></h3><p>提案，stage1 阶段。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/posts/tags/javascript>JavaScript</a></li></ul></nav></div></article></main><footer><hr>⚡️
2020 © yrjkqq | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>