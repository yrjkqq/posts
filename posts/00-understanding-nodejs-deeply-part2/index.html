<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>《深入浅出 Node.js》学习笔记 Part2 - That's the Way It Is</title><link rel=icon type=image/png href=/posts/img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:description" content="Buffer, 网络编程"><meta name=twitter:description content="Buffer, 网络编程"><meta name=description content="Buffer, 网络编程"><meta name=description content="Buffer, 网络编程"><meta property="og:title" content="《深入浅出 Node.js》学习笔记 Part2 | That's the Way It Is"><meta name=twitter:title content="《深入浅出 Node.js》学习笔记 Part2 | That's the Way It Is"><meta property="og:image" content><meta itemprop=name content="《深入浅出 Node.js》学习笔记 Part2 | That's the Way It Is"><meta name=application-name content="《深入浅出 Node.js》学习笔记 Part2 | That's the Way It Is"><meta property="og:site_name" content><meta property="og:title" content="《深入浅出 Node.js》学习笔记 Part2"><meta property="og:description" content="Buffer, 网络编程"><meta property="og:type" content="article"><meta property="og:url" content="https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/"><meta property="article:published_time" content="2019-01-09T16:41:00+08:00"><meta property="article:modified_time" content="2019-01-09T16:41:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="《深入浅出 Node.js》学习笔记 Part2"><meta name=twitter:description content="Buffer, 网络编程"><link href=https://yrjkqq.github.io/posts/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://yrjkqq.github.io/posts/css/main.css><link rel=stylesheet type=text/css href=https://yrjkqq.github.io/posts/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://yrjkqq.github.io/posts/>That's the Way It Is</a></div><nav><a href=/posts/tags>Tags</a>
<a href=/posts/posts>All</a></nav></header><main><article><div class=title><h1 class=title>《深入浅出 Node.js》学习笔记 Part2</h1><div class=meta>Posted on Jan 9, 2019</div></div><section class=body><h2 id=第-6-章-理解-buffer>第 6 章 理解 Buffer</h2><p>在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接受文件上传等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是有了 Buffer.</p><h3 id=buffer-结构>Buffer 结构</h3><p>Buffer 类似于 Array, 但主要用于操作字节。Buffer 是一个由 JavaScript 和 C++ 结合的模块，C++ 实现性能相关的部分。Buffer 所占用的内存不通过 V8 分配，属于堆外内存，有更高效和专用的内存分配策略。Buffer 位于全局对象 global 上，无需导入。</p><p>Buffer 内存分配：在 C++ 层面申请内存，在 JavaScript 上分配内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和时候分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。大块的 Buffer 直接调用 C++ 层面提供的内存。</p><h3 id=buffer-的转换>Buffer 的转换</h3><p><strong>字符串 -> Buffer 对象</strong>：<a href=http://nodejs.cn/api/buffer.html#buffer_static_method_buffer_from_string_encoding>Buffer.from(string[, encoding])</a> encoding 默认为 &lsquo;utf8&rsquo;. 一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 <code>write()</code> 方法实现。</p><p><strong>Buffer 对象 -> 字符串</strong>：<a href=http://nodejs.cn/api/buffer.html#buffer_buf_tostring_encoding_start_end>buf.toString([encoding[, start[, end]]])</a></p><p>Buffer 支持的编码类型：<a href=http://nodejs.cn/api/buffer.html#buffer_buffers_and_character_encodings>Buffer 与字符编码</a></p><ul><li>字符编码：utf8 utf16le latin1</li><li>二进制转文本的编码：base64 hex</li><li>传统的字符串编码：ascii binary ucs2</li></ul><h3 id=buffer-的拼接>Buffer 的拼接</h3><p>从常见的输入流从读取内容的示例代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 从输入流读取内容
</span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>fs</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;fs&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>dirname</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;path&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>fileURLToPath</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;url&#34;</span>;

<span style=color:#75715e>// 使用 ECMAScript modules 之后，需要如下两行代码来使用 __dirname 或 __filename
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>__filename</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fileURLToPath</span>(<span style=color:#66d9ef>import</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>url</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>dirname</span>(<span style=color:#a6e22e>__filename</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>__filename</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>__dirname</span>);

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>createReadStream</span>(<span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/README.md&#34;</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
<span style=color:#a6e22e>rs</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>chunk</span>) {
  <span style=color:#75715e>// 这里隐藏了 data = data.toString() + chunk.toString() chunk 为 Buffer 时，会以 utf-8 的转换成字符串
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>data</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>chunk</span>;
});
<span style=color:#a6e22e>rs</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;end&#34;</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>data</span>);
});
</code></pre></div><p>以上代码在遇到宽字节的中文时可能会出现乱码。将文件可读流的每次读取的 Buffer 的长度限制为 11 模拟乱码的情况：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>createReadStream</span>(<span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/README.md&#34;</span>, { <span style=color:#a6e22e>highWaterMark</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>11</span> });
</code></pre></div><p>此时会输出：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>代码来</span><span style=color:#960050;background-color:#1e0010>��</span><span style=color:#a6e22e>于</span> <span style=color:#960050;background-color:#1e0010>《</span><span style=color:#a6e22e>深入浅出</span> <span style=color:#a6e22e>Node</span>.<span style=color:#a6e22e>js</span><span style=color:#960050;background-color:#1e0010>》</span> <span style=color:#960050;background-color:#1e0010>���</span><span style=color:#a6e22e>书</span>
</code></pre></div><p>出现乱码的原因在于文件可读流在读取时会逐个读取 Buffer。代码中限定了每个 Buffer 的长度为 11 个字节。第一个 Buffer 按照每个中文字 3 个字节的 utf-8 格式解码时，只能解码出 9 个字节，剩余两个字节无法解码，出现乱码。下一个 Buffer 头部也会出现一个字节无法被解码，产生一个乱码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>Buffer</span>.<span style=color:#a6e22e>from</span>(<span style=color:#e6db74>&#34;代码来自于 《深入浅出 Node.js》 一书&#34;</span>));
<span style=color:#75715e>// 使用前 11 个字节，输出就会乱码
</span><span style=color:#75715e></span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>Buffer</span>.<span style=color:#a6e22e>from</span>(<span style=color:#e6db74>&#34;e4bba3e7a081e69da5e887&#34;</span>, <span style=color:#e6db74>&#34;hex&#34;</span>).<span style=color:#a6e22e>toString</span>());
<span style=color:#75715e>// &lt;Buffer e4 bb a3 e7 a0 81 e6 9d a5 e8 87 aa e4 ba 8e 20 e3 80 8a e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 20 4e 6f 64 65 2e 6a 73 e3 80 8b 20 e4 b8 80 e4 b9 a6&gt;
</span><span style=color:#75715e>// 代码来�
</span></code></pre></div><p>解决：</p><ol><li>添加 <code>setEncoding('utf-8')</code>, 设置编码后让 data 事件中传递的不再是一个 Buffer 对象，而是编码后的字符串。调用该方法时，可读流对象在内部设置了一个 decoder 对象，每次 data 事件都通过该 decoder 对象进行 Buffer 到字符串的解码，然后传递给调用者。decoder 对象来自于 string_decoder 模块 <a href=https://nodejs.org/dist/latest-v14.x/docs/api/string_decoder.html#string_decoder_string_decoder>StringDecoder</a> 的实例。<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>createReadStream</span>(<span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/README.md&#34;</span>, { <span style=color:#a6e22e>highWaterMark</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>11</span> });
<span style=color:#a6e22e>rs</span>.<span style=color:#a6e22e>setEncoding</span>(<span style=color:#e6db74>&#34;utf-8&#34;</span>); 
</code></pre></div><p>当把 Buffer 对象写入到 StringDecoder 实例时，decoder 内部会使用一个 buffer 确保编码的文本不包含任何不完整的多字节字符，这些不完整的字符被保留在内部 buffer 里，直到下一次调用 <code>stringDecoder.write()</code> 或调用 <code>stringDecoder.end()</code> 方法时，将不完整的字符与这一次写入的 Buffer 对象合并。</p></li></ol><h4 id=正确拼接-buffer>正确拼接 Buffer</h4><p>使用 <a href=https://nodejs.org/dist/latest-v14.x/docs/api/buffer.html#buffer_static_method_buffer_concat_list_totallength>Buffer.concat(list[, totalLength])</a> 拼接多个 buffer 对象：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 正确拼接 Buffer
</span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>fs</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;fs&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>dirname</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;path&#34;</span>;
<span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>fileURLToPath</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;url&#34;</span>;

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>__filename</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fileURLToPath</span>(<span style=color:#66d9ef>import</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>url</span>);
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>dirname</span>(<span style=color:#a6e22e>__filename</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>__filename</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>__dirname</span>);

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>res</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>createReadStream</span>(<span style=color:#a6e22e>__dirname</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/README.md&#34;</span>);
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>chunks</span> <span style=color:#f92672>=</span> [];
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>chunk</span>) {
  <span style=color:#a6e22e>chunks</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>chunk</span>);
  <span style=color:#a6e22e>size</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>length</span>;
});
<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#34;end&#34;</span>, <span style=color:#66d9ef>function</span> () {
  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Buffer</span>.<span style=color:#a6e22e>concat</span>(<span style=color:#a6e22e>chunks</span>, <span style=color:#a6e22e>size</span>);
  <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>buf</span>.<span style=color:#a6e22e>toString</span>(<span style=color:#e6db74>&#34;utf-8&#34;</span>));
});
</code></pre></div><h3 id=buffer-与性能>Buffer 与性能</h3><p>在 web 应用中，提高字符串转换到 Buffer 的效率，可以达成的地提高网络吞吐率。<br>使用 <a href=https://www.tutorialspoint.com/apache_bench/apache_bench_environment_setup.htm>apache ab</a> 工具可以测试 web 服务器的性能，比较转换到 buffer 和不转换的 QPS(每秒查询次数)。<br>在 Node 构建的 web 应用中，可以选择将页面中的动态内容和精通内容分离，静态内容部分可以通过预先转换为 Buffer 的方式提高性能。文件读取尽量只读取为 buffer 然后直接传输，不做额外的转换。</p><h2 id=第-7-章-网络编程>第 7 章 网络编程</h2><p>直接看原书。</p><h2 id=地-8-章-构建-web-应用>地 8 章 构建 web 应用</h2><p>直接看原书。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/posts/tags/node>Node</a></li></ul></nav></div></article></main><footer><hr>⚡️
2021 © yrjkqq | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>