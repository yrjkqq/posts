<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>React Hooks 性能优化 - That's the Way It Is</title><link rel=icon type=image/png href=/posts/img/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:description" content="探索使用 React Hooks 后常用的优化手段"><meta name=twitter:description content="探索使用 React Hooks 后常用的优化手段"><meta name=description content="探索使用 React Hooks 后常用的优化手段"><meta name=description content="探索使用 React Hooks 后常用的优化手段"><meta property="og:title" content="React Hooks 性能优化 | That's the Way It Is"><meta name=twitter:title content="React Hooks 性能优化 | That's the Way It Is"><meta property="og:image" content><meta itemprop=name content="React Hooks 性能优化 | That's the Way It Is"><meta name=application-name content="React Hooks 性能优化 | That's the Way It Is"><meta property="og:site_name" content><meta property="og:title" content="React Hooks 性能优化"><meta property="og:description" content="探索使用 React Hooks 后常用的优化手段"><meta property="og:type" content="article"><meta property="og:url" content="https://yrjkqq.github.io/posts/posts/08-react-hooks-performance-optimization/"><meta property="article:published_time" content="2020-11-13T00:35:00+08:00"><meta property="article:modified_time" content="2020-11-13T00:35:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="React Hooks 性能优化"><meta name=twitter:description content="探索使用 React Hooks 后常用的优化手段"><link href=https://yrjkqq.github.io/posts/css/fonts.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://yrjkqq.github.io/posts/css/main.css><link rel=stylesheet type=text/css href=https://yrjkqq.github.io/posts/css/dark.css media="(prefers-color-scheme: dark)"></head><body><div class=content><header><div class=main><a href=https://yrjkqq.github.io/posts/>That's the Way It Is</a></div><nav><a href=/posts/tags>Tags</a>
<a href=/posts/posts>All</a></nav></header><main><article><div class=title><h1 class=title>React Hooks 性能优化</h1><div class=meta>Posted on Nov 13, 2020</div></div><section class=body><p>React 16.8.0 引入 Hook 之后，新写的项目中基本上全部采用 Hook 的写法。</p><p>Hook 与 Class 相比，主要带来以下几方面的优势：</p><ul><li><strong>复杂组件变得难以理解</strong><br>Class 组件中需要将各个业务代码写在各个生命周期函数中，可能存在同样的功能分布在各个生命周期函数中，代码逻混乱，尤其是在复杂组件中。而 Hook 将组件中相互关联的部分拆分成更小的函数，而非强制按照生命周期划分。</li><li><strong>在组件之间复用状态逻辑很难</strong><br>React 中会使用到 <code>render props</code> 或 <code>高阶组件</code> 来解决逻辑复用的问题，但这些方式需要改变代码结构，例如使用高阶函数后会产生组件嵌套，层次太多就会产生嵌套地狱。而 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用，并且无需修改代码结构。</li><li><strong>难以理解的 Class</strong><br>Class 由于 JavaScript 语言的特殊性，在实现方面没有稳定的提案，相比于函数式组件学习成本更高，例如 <code>this</code> 的使用或者绑定事件函数。同时，Class 组件会使一些新的优化手段无法在 React 实现，例如组件预编译。而且 Class 不能进行很好的压缩。</li></ul><p>Hook 可以在使用函数式组件的情况下使用到更多的 React 特性。但是切换到 Hook 之后，就会就会存在之前的一些优化手段需要使用对应的 Hook 写法。</p><p>使用 Class 组件时，常见的优化手段：</p><ul><li><strong>Component 类组件使用 <code>shouldComponentUpdate</code></strong><br>可以根据 <code>shouldComponentUpdate</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。在该方法内部进行对变化前后的 props 和 state 进行比较，返回则会跳过更新，即不会吊桶 <code>render()</code> 和 <code>componentDidUpdate()</code>. 但是返回 false 并不会阻止子组件在 state 变化重新渲染。</li><li><strong>使用 React.PureComponent 组件</strong><br>如果手动编写的 shouldComponentUpdate 组件只是对 state 或 props 进行了浅层比较，那么可以直接使用 PureComponent 组件，该组件以浅层比较 state 和 props 的方式实现了 shouldComponentUpdate 函数。React.Component 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新，所以需要确保子组件也是纯组件。</li><li><strong>使用不可变数据</strong><br>使用 PureComponent 进行浅层比较时，对象类型例如数组，那么数组添加元素后，对象引用没有变，那么组件不会进行更新。可以使用扩展运算符来返回一个新的对象和数组，即可解决。或者是直接使用 immer 这些库来解决深层嵌套的问题。</li></ul><p>再切换到 Hook 之后，常见的优化手段：</p><ul><li><p><strong>条件式的跳过 effect</strong><br>设置依赖数组</p></li><li><p><strong>在依赖列表中省略函数</strong><br>通常需要在 effect 中声明它所需要的函数，这样比较清楚的看出函数依赖了哪些 state 或 props. 如果无法将函数移动或声明在 effect 内部，有一些其他办法：</p><ul><li>将函数移动到组件之外</li><li>在 effect 外调用这个函数，然后让 effect 依赖它的返回值</li><li>使用 useCallback 包裹该函数，那么重新渲染前后该函数不会发生改变，那么在 effect 中再依赖这个包裹的函数，即可保证 effect 不会由于函数的变化而发生不必要的调用（函数本身也是一个对象，如果直接依赖未包裹的函数，那么把函数传入子组件并且子组件的 effect 依赖这个函数后，在每次父组件更新时，都会产生一个新的函数，虽然新旧函数完全一致，但浅比较的结果依然不同，那么子组件的 effect 会由于依赖项数组变化依然会被执行）。示例代码：<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProductPage</span>({ <span style=color:#a6e22e>productId</span> }) {
  <span style=color:#75715e>// ✅ 用 useCallback 包裹以避免随渲染发生改变
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fetchProduct</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useCallback</span>(() =&gt; {
    <span style=color:#75715e>// ... Does something with productId ...
</span><span style=color:#75715e></span>  }, [<span style=color:#a6e22e>productId</span>]); <span style=color:#75715e>// ✅ useCallback 的所有依赖都被指定了
</span><span style=color:#75715e></span>
  <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>ProductDetails</span> <span style=color:#a6e22e>fetchProduct</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>fetchProduct</span>} <span style=color:#f92672>/&gt;</span>;
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProductDetails</span>({ <span style=color:#a6e22e>fetchProduct</span> }) {
  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
    <span style=color:#a6e22e>fetchProduct</span>();
  }, [<span style=color:#a6e22e>fetchProduct</span>]); <span style=color:#75715e>// ✅ useEffect 的所有依赖都被指定了
</span><span style=color:#75715e></span>  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div></li></ul></li><li><p><strong>effect 的依赖项频繁变化</strong><br>使用 <a href=https://zh-hans.reactjs.org/docs/hooks-reference.html#functional-updates>setState 的函数式更新方式</a> , setState 会接受一个回调函数，该函数将接受之前的 state 便返回更新后的值。那么在 effect 中可以不用直接依赖 state 而内部又可以使用到 state 进行计算, 在 state 变化后不会触发 effect 的重复执行。<br>在更复杂的场景中，可以使用 useReducer 将 state 的更新逻辑移动到 effect 之外。useReducer 的 dispatch 函数永远是稳定的。</p></li><li><p><strong>实现 shouldComponentUpdate</strong><br>使用 <code>React.memo</code> 包括一个组件，memo 会对包裹组件的 props 进行浅比较。等效于 PureComponent，但只比较 props. memo 也接受第二个参数指定一个自定义的比较函数来比较新旧 props，来决定是否跳过更新。</p></li><li><p><strong>useMemo 记忆计算结果</strong><br>useMemo 允许记住上一次计算结果，在多次渲染之间缓存结果：<code>const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);</code>，依赖项数组没有改变，则会跳过二次调用，只返回上一次返回的值。
使用 useMemo 来优化每一个具体的子结点，并可以跳过子节点的更新，代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JS data-lang=JS><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Parent</span>({ <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> }) {
  <span style=color:#75715e>// Only re-rendered if `a` changes:
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>child1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Child1</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>a</span>} <span style=color:#f92672>/&gt;</span>, [<span style=color:#a6e22e>a</span>]);
  <span style=color:#75715e>// Only re-rendered if `b` changes:
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>child2</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>Child2</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>b</span>} <span style=color:#f92672>/&gt;</span>, [<span style=color:#a6e22e>b</span>]);
  <span style=color:#66d9ef>return</span> (
    <span style=color:#f92672>&lt;&gt;</span>
      {<span style=color:#a6e22e>child1</span>}
      {<span style=color:#a6e22e>child2</span>}
    <span style=color:#f92672>&lt;</span><span style=color:#960050;background-color:#1e0010>/&gt;</span>
  )
}
</code></pre></div></li><li><p><strong>如何创建昂贵的对象？</strong><br><a href=https://zh-hans.reactjs.org/docs/hooks-reference.html#lazy-initial-state>useState 可以接受一个函数作为参数</a>，这个函数只会在首次渲染时调用这个函数，后续渲染会被忽略。<em>React 会确保 setState 函数的标识是稳定的，并且不会在组件重新渲染时发生变化，所以可以在 effect 的依赖项中忽略 setState</em></p></li><li><p><strong>Hook 会在渲染时因为创建函数而变慢吗？</strong><br>闭包在极端的场景下可会和类的性能有明显差别。但是 Hook 在某些方面更加高效：</p><ul><li>Hook 避免了创建 class 需要的额外开支。</li><li>在使用 Hook 时不需要很深的组件树嵌套。相比于使用高阶组件、render props 和 context 更少使用组件嵌套。</li></ul><p>在 React 中使用内联函数对性能的影响，与每次渲染都传递新的回调会破坏子组件的 shouldComponentUpdate 有关。函数本身也是一个对象，在每次渲染时都会重新创建，如果这些函数被传入子组件，而子组件由 PureComponent 或类似实现，那么在比较 props 时，props 中有回调函数，浅比较中前后两次的回调函数会返回 false, 导致子组件重新渲染。而如果子组件中的 effect 依赖了该回调函数，也会被重新执行。解决这个问题有以下三种方法：</p><ul><li>使用 useCallback 包裹这个回调函数，那么在重新渲染之间会保持对相同的回调函数的应用，使得子组件的 shouldComponent 或 effect 依赖数组的浅比较得以正常工作<div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 除非 `a` 或 `b` 改变，否则不会变
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>memoizedCallback</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useCallback</span>(() =&gt; {
  <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>);
}, [<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>]);
</code></pre></div></li><li>使用 useMemo 来控制子节点何时更新，而不直接使用 PureComponent</li><li>使用 useReducer，不传递回调函数，而传递 dispatch 函数，因为 dispatch 函数在重新渲染之间是保持稳定的</li></ul></li><li><p><strong>如何避免向下传递回调？</strong><br>组件树中传递回调函数在写法上更明确，但是管理很麻烦，而且存在上一节中存在的问题。在大型的组件树中，可以通过用 context 用 useReducer 往下传递 dispatch 函数，这样更加方便维护，不用不断转发回调。<code>dispatch 是处理深度更新的推荐模式。</code>子组件使用 dispatch 函数向上传递 action 来更新 content.</p></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/posts/tags/react>React</a></li></ul></nav></div></article></main><footer><hr>⚡️
2021 © yrjkqq | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></footer></div></body></html>