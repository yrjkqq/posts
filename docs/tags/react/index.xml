<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on That&#39;s the Way It Is</title>
    <link>https://yrjkqq.github.io/posts/tags/react/</link>
    <description>Recent content in React on That&#39;s the Way It Is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© yrjkqq</copyright>
    <lastBuildDate>Thu, 19 Nov 2020 00:08:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/tags/react/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>React 结合 Immutable 进行性能优化</title>
      <link>https://yrjkqq.github.io/posts/posts/10-performance-optimization-with-immutable/</link>
      <pubDate>Thu, 19 Nov 2020 00:08:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/10-performance-optimization-with-immutable/</guid>
      <description>React 中虽然可以使用 useMemo useCallback React.memo 等 api 进行性能优化，但是如果是复杂场景下的复杂数据的更新，使用 Immutable 是更合适的。
在下面这个例子中:
import * as React from &amp;#34;react&amp;#34;; import &amp;#34;./styles.css&amp;#34;; import { List } from &amp;#34;immutable&amp;#34;; function ListChild({ names }) { const [v, setV] = React.useState(&amp;#34;a&amp;#34;); return ( &amp;lt;div&amp;gt; {Date.now()}-{names.join(&amp;#34;,&amp;#34;)} &amp;lt;input value={v} onChange={(e) =&amp;gt; setV(e.target.value)} /&amp;gt; &amp;lt;/div&amp;gt; ); } const MemoListChild = React.memo(ListChild, (prevProps, nextProps) =&amp;gt; { return prevProps.names.equals(nextProps.names); }); export default function App() { const [value, setValue] = React.useState(&amp;#34;&amp;#34;); const [names, setNames] = React.</description>
    </item>
    
    <item>
      <title>React Hooks 性能优化</title>
      <link>https://yrjkqq.github.io/posts/posts/08-react-hooks-performance-optimization/</link>
      <pubDate>Fri, 13 Nov 2020 00:35:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/08-react-hooks-performance-optimization/</guid>
      <description>React 16.8.0 引入 Hook 之后，新写的项目中基本上全部采用 Hook 的写法。
Hook 与 Class 相比，主要带来以下几方面的优势：
 复杂组件变得难以理解
Class 组件中需要将各个业务代码写在各个生命周期函数中，可能存在同样的功能分布在各个生命周期函数中，代码逻混乱，尤其是在复杂组件中。而 Hook 将组件中相互关联的部分拆分成更小的函数，而非强制按照生命周期划分。 在组件之间复用状态逻辑很难
React 中会使用到 render props 或 高阶组件 来解决逻辑复用的问题，但这些方式需要改变代码结构，例如使用高阶函数后会产生组件嵌套，层次太多就会产生嵌套地狱。而 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用，并且无需修改代码结构。 难以理解的 Class
Class 由于 JavaScript 语言的特殊性，在实现方面没有稳定的提案，相比于函数式组件学习成本更高，例如 this 的使用或者绑定事件函数。同时，Class 组件会使一些新的优化手段无法在 React 实现，例如组件预编译。而且 Class 不能进行很好的压缩。  Hook 可以在使用函数式组件的情况下使用到更多的 React 特性。但是切换到 Hook 之后，就会就会存在之前的一些优化手段需要使用对应的 Hook 写法。
使用 Class 组件时，常见的优化手段：
 Component 类组件使用 shouldComponentUpdate 可以根据 shouldComponentUpdate 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。在该方法内部进行对变化前后的 props 和 state 进行比较，返回则会跳过更新，即不会吊桶 render() 和 componentDidUpdate().</description>
    </item>
    
    <item>
      <title>React Fiber 架构</title>
      <link>https://yrjkqq.github.io/posts/posts/09-react-fiber/</link>
      <pubDate>Thu, 12 Nov 2020 11:12:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/09-react-fiber/</guid>
      <description>Fiber 架构主要是使用了新的 reconciler 调谐器，区别于 React 15 的 stack reconciler 调谐器。
Reconciliation 协调主要是是 Diffing 算法。基于两个前提：
 两个不同类型的元素会产生不同的树 开发者可以通过 key prop 来暗示那些子元素在不同的渲染下能保持稳定  启发性算法复杂度由之前的 O(n^3) 将低到 O(n)。
不同类型的元素：根节点不通，直接会卸载原来的树并构建新的树。
对比同一类型的 DOM 元素：保留 DOM 节点，仅比对及更新有改变的属性。
同一类型的组件元素：当一个组件更新时，组件实例保持不变，state 在跨越不同的渲染时保持一致。React 将更新组件实例的 props 以跟最新的元素保持一致，并调用 componentWillUpdate 方法。
下一步调用 render 方法，diff 算法将在之前的结果以及新的结果中进行递归。
key 属性，React 使用 key 属性来匹配原有树上的子元素和最新树上的子元素，匹配到则检测更新，否则就新增结点或删除。没有 key 则会对整个节点树进行比较。
满足假设：
 类似的组件应该封装成同一类型，有利于 React 进行匹配 key 保持稳定并唯一。  </description>
    </item>
    
  </channel>
</rss>
