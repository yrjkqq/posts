<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node on That&#39;s the Way It Is</title>
    <link>https://yrjkqq.github.io/posts/tags/node/</link>
    <description>Recent content in Node on That&#39;s the Way It Is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© yrjkqq</copyright>
    <lastBuildDate>Tue, 12 May 2020 09:45:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/tags/node/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Next.js 源码阅读</title>
      <link>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</link>
      <pubDate>Tue, 12 May 2020 09:45:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</guid>
      <description>前言 Next.js 官方文档不是很详细，一些细节部分需要深入到源码中，才能知其所以然。按照官方贡献指南 Fork 项目到自己的仓库，然后 clone 下来。以最新的 canary 分支版本 10.0.1-canary.4 为基础。
项目结构 深入到源码之前，先摸清楚整个项目的结构。
源码中使用 lerna 在 packages 目录下放置了多个包，每个包有自己的 package.json 文件。使用类似 learn run command 的命令时，会同时运行 packages 目录所有包中可以运行该 command 的命令。
目录结构：
 .vscode 目录下放置了 vscode 相关的配置文件。 bench 目录放置了运行 benchmarks 的代码和文档。 docs 目录下是官方文档。 errors 目录下使用了 Next.js 过程中可能会遇到的错误，记录了错误发生的原因和解决方法。 examples 目录下放置了 Next.js 的用法，或是与各种第三方库或框架结合使用的样例代码 packages 源代码目录，后面主要是阅读这里面的代码 test 测试代码和测试用例  其他比较重要的文件：
 .eslintrc.json ESLint 的配置文件 .prettierrc.json Prettier 的配置文件 jest.config.js 测试框架 jest 的配置文件 lerna.json lerna 的配置文件 package.json 包描述文件，记录了所有可以运行的脚本  阅读前准备 按照官方贡献指南，安装完依赖后，运行 node --inspect packages/next/dist/bin/next dev test/integration/basic 没有报错，然后打开 http://localhost:3000/about 查看页面正常，就安装运行完成。</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记 Part2</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</link>
      <pubDate>Wed, 09 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</guid>
      <description>第 6 章 理解 Buffer 在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接受文件上传等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是有了 Buffer.
Buffer 结构 Buffer 类似于 Array, 但主要用于操作字节。Buffer 是一个由 JavaScript 和 C++ 结合的模块，C++ 实现性能相关的部分。Buffer 所占用的内存不通过 V8 分配，属于堆外内存，有更高效和专用的内存分配策略。Buffer 位于全局对象 global 上，无需导入。
Buffer 内存分配：在 C++ 层面申请内存，在 JavaScript 上分配内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和时候分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。大块的 Buffer 直接调用 C++ 层面提供的内存。
Buffer 的转换 字符串 -&amp;gt; Buffer 对象：Buffer.from(string[, encoding]) encoding 默认为 &amp;lsquo;utf8&amp;rsquo;. 一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法实现。
Buffer 对象 -&amp;gt; 字符串：buf.toString([encoding[, start[, end]]])
Buffer 支持的编码类型：Buffer 与字符编码
 字符编码：utf8 utf16le latin1 二进制转文本的编码：base64 hex 传统的字符串编码：ascii binary ucs2  Buffer 的拼接 从常见的输入流从读取内容的示例代码：</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记 Part1</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</link>
      <pubDate>Wed, 02 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</guid>
      <description>第 3 章 异步 I/O 异步 I/O 主要关注点在用户体验和资源分配。
用户体验方面，异步方式在响应请求方面显著降低了同步请求的等待时间，由 M+N 降低为 max(M+N)。
Node 利用单线程，解决了多线程编程模型中死锁、状态同步等问题，结合异步 I/O 解决了单线程串行依次执行编程模型因阻塞 I/O 导致资源得不到更优应用的问题。
操作系统对异步 I/O 的支持 非阻塞 I/O 在调用后会立即返回，但是由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅时调用状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作即轮询来确认是否完成。
现有的轮询技术主要有：read select poll epoll kqueue
单线程中实现异步 I/O 总会有各种缺陷，但是利用多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，即可模拟出异步 I/O.
Node 在 linux 下通过自行实现线程池，在 windows 下使用 IOCP(内核管理的线程池)，并且提供 libuv 对平台差异性进行抽象封装，来实现异步 I/O.
Node 如何实现异步 I/O 完成整个异步 I/O 环节的有事件循环、观察者模式、请求对象、I/O 线程池。
事件循环：Node 自身的执行模型。在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们成为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有则取出事件和对应的回调函数。如果存在关联的回调函数，就执行。然后进入下个循环，直到不再有事件处理。
每个事件循环有一个或多个观察者，而判断是否有事件要处理的过程则是向这些观察者询问是否有要处理的事件。
生产者/消费者模型：异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些时间被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</description>
    </item>
    
    <item>
      <title>Node.js 中的 stream</title>
      <link>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</link>
      <pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</guid>
      <description>stream 模块用于构建实现了流接口的对象。Node.js 提供了多种流对象。流可以是可读的、可写的、或者可读可写的。所有的流都是 EventEmitter 的实例。
流的类型：
 Writable 可写入数据的流，如 fs.createWriteStream() Readable 可读取数据的流，如 fs.createReadStream() Duplex 可读又可写的流，如 net.Socket Transform 在读写过程中可以修改或转换数据的 Duplex 流，如 zlib.createDeflate()  Node.js 创建的流都是运行在字符串和 Buffer (或 Uint8Array) 上。流的实现也可以使用其他类型的 JavaScript 值（除了 null）。
使用 stream 实现的 http 服务器:
import http from &amp;#34;http&amp;#34;; const server = http.createServer(function (req, res) { // req 是一个 http.IncomingMessage 实例，是可读流  // res 是一个 http.ServerResponse 实例，是可写流  let body = &amp;#34;&amp;#34;; // 接收数据为 utf8 字符串  // 如果没有设置字符编码，则会接收到 Buffer 对象  req.</description>
    </item>
    
  </channel>
</rss>
