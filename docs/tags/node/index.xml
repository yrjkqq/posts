<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node on That&#39;s the Way It Is</title>
    <link>https://yrjkqq.github.io/posts/tags/node/</link>
    <description>Recent content in Node on That&#39;s the Way It Is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© yrjkqq</copyright>
    <lastBuildDate>Thu, 05 Nov 2020 15:30:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/tags/node/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>URL 模块和 querystring 模块</title>
      <link>https://yrjkqq.github.io/posts/posts/07-url-urlsearchparams-querystring/</link>
      <pubDate>Thu, 05 Nov 2020 15:30:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/07-url-urlsearchparams-querystring/</guid>
      <description>url 模块提供了解析 URL 的工具。const url = require(&#39;url&#39;)
url 模块提供了两套 API:
 legacy API, Node.js 特有 WHATWG URL Standard, 用于 web 浏览器  // WHATWG API const myURL = new URL(&amp;#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&amp;#39;); /** &amp;gt; myURL URL { href: &amp;#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&amp;#39;, origin: &amp;#39;https://sub.example.com:8080&amp;#39;, protocol: &amp;#39;https:&amp;#39;, username: &amp;#39;user&amp;#39;, password: &amp;#39;pass&amp;#39;, host: &amp;#39;sub.example.com:8080&amp;#39;, hostname: &amp;#39;sub.example.com&amp;#39;, port: &amp;#39;8080&amp;#39;, pathname: &amp;#39;/p/a/t/h&amp;#39;, search: &amp;#39;?query=string&amp;#39;, searchParams: URLSearchParams { &amp;#39;query&amp;#39; =&amp;gt; &amp;#39;string&amp;#39; }, hash: &amp;#39;#hash&amp;#39; } */ // Legacy API const url = require(&amp;#39;url&amp;#39;); const myURL = url.</description>
    </item>
    
    <item>
      <title>Next.js 源码阅读</title>
      <link>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</link>
      <pubDate>Tue, 12 May 2020 09:45:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</guid>
      <description>前言 Next.js 官方文档不是很详细，一些细节部分需要深入到源码中，才能知其所以然。按照官方贡献指南 Fork 项目到自己的仓库，然后 clone 下来。以最新的 canary 分支版本 10.0.1-canary.4 为基础。
项目结构 深入到源码之前，先摸清楚整个项目的结构。
源码中使用 lerna 在 packages 目录下放置了多个包，每个包有自己的 package.json 文件。使用类似 learn run command 的命令时，会同时运行 packages 目录所有包中可以运行该 command 的命令。
目录结构：
 .vscode 目录下放置了 vscode 相关的配置文件。 bench 目录放置了运行 benchmarks 的代码和文档。 docs 目录下是官方文档。 errors 目录下使用了 Next.js 过程中可能会遇到的错误，记录了错误发生的原因和解决方法。 examples 目录下放置了 Next.js 的用法，或是与各种第三方库或框架结合使用的样例代码 packages 源代码目录，后面主要是阅读这里面的代码 test 测试代码和测试用例  其他比较重要的文件：
 .eslintrc.json ESLint 的配置文件 .prettierrc.json Prettier 的配置文件 jest.config.js 测试框架 jest 的配置文件 lerna.json lerna 的配置文件 package.json 包描述文件，记录了所有可以运行的脚本  阅读前准备 按照官方贡献指南，安装完依赖后，运行 node --inspect packages/next/dist/bin/next dev test/integration/basic 没有报错，然后打开 http://localhost:3000/about 查看页面正常，就安装运行完成。</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记 Part4</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part4/</link>
      <pubDate>Fri, 18 Jan 2019 21:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part4/</guid>
      <description>第 10 章 测试 略。
第 11 章 产品化 项目工程化：
 目录结构 Project Structure Practices 构建工具 Grunt 编码规范 ESLint 代码审查  部署流程
性能：
 动静分离：Nginx CDN 启用缓存：Redis 多进程架构：官方 process_child cluster 模块，社区的 pm2 模块进行进程管理 读写分离：数据库读写分离  日志：
 winston 库  监控报警：
 日志监控 响应时间 进程监控 磁盘监控 内存监控 CPU 占用监控 CPU load 监控 I/O 负载 网络监控 应用状态监控 DNS 监控  报警：
 邮件报警：nodemailer 模块发送邮件 短信或电话报警  稳定性： 多进程、多机器、多机房，分布式设计。 容灾备份
异构共存： 协议</description>
    </item>
    
    <item>
      <title>Node.js 的 child_process, cluster, worker_threads 模块</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part3/</link>
      <pubDate>Mon, 14 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part3/</guid>
      <description>Node 并非真正的单线程架构，有一些 I/O 线程由底层 libuv 处理。JavaScript 代码永远运行在 V8 上，是单线程的。
多线程中，每个线程都拥有自己独立的堆栈，这个堆栈需要占用一定的内存空间。由于一个 CPU 核心在一个时刻只能做一件事情，操作系统只能通过将 CPU 切分为时间片的方法，让线程可以较为均匀地使用 CPU 资源。但是操作系统在切换线程的同时也要切换线程的上下文，当线程数量过多时，事件会被消耗到上下文切换中。Node 基于事件驱动，采用单线程避免了不必要的内存开销和上下文切换开销。
Node 中所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，但它不受多进程或多线程中资源上限的影响，可伸缩性远比前两者更高。也就是说，CPU 计算能力可以通过增加 CPU 核心的数量来进行提高，进一步提高 Node 的性能。那么 Node 中如何利用多核 CPU 呢？
如何提高 CPU 的利用率？ 解决单线程单进程堆多核使用不足的问题：理想状态下每个进程各自利用一个 CPU, 以此实现多核 CPU 的利用。Node 提供了 child_process 模块。
Master-Worker 主从模式：分布式架构中用于并行处理业务的模式。主进程不负责具体的业务处理，而是负责调度和管理工作进程，趋于稳定。工作进程负责具体的业务处理，需要关注其稳定性。示例代码如下：
// master.js import childProcess from &amp;#34;child_process&amp;#34;; import os from &amp;#34;os&amp;#34;; import { dirname } from &amp;#34;path&amp;#34;; import { fileURLToPath } from &amp;#34;url&amp;#34;; const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); // 获取操作系统的 cpu 的核心数 const cpus = os.</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记 Part2</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</link>
      <pubDate>Wed, 09 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</guid>
      <description>第 6 章 理解 Buffer 在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接受文件上传等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是有了 Buffer.
Buffer 结构 Buffer 类似于 Array, 但主要用于操作字节。Buffer 是一个由 JavaScript 和 C++ 结合的模块，C++ 实现性能相关的部分。Buffer 所占用的内存不通过 V8 分配，属于堆外内存，有更高效和专用的内存分配策略。Buffer 位于全局对象 global 上，无需导入。
Buffer 内存分配：在 C++ 层面申请内存，在 JavaScript 上分配内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和时候分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。大块的 Buffer 直接调用 C++ 层面提供的内存。
Buffer 的转换 字符串 -&amp;gt; Buffer 对象：Buffer.from(string[, encoding]) encoding 默认为 &amp;lsquo;utf8&amp;rsquo;. 一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法实现。
Buffer 对象 -&amp;gt; 字符串：buf.toString([encoding[, start[, end]]])
Buffer 支持的编码类型：Buffer 与字符编码
 字符编码：utf8 utf16le latin1 二进制转文本的编码：base64 hex 传统的字符串编码：ascii binary ucs2  Buffer 的拼接 从常见的输入流从读取内容的示例代码：</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记 Part1</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</link>
      <pubDate>Wed, 02 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</guid>
      <description>第 3 章 异步 I/O 异步 I/O 主要关注点在用户体验和资源分配。
用户体验方面，异步方式在响应请求方面显著降低了同步请求的等待时间，由 M+N 降低为 max(M+N)。
Node 利用单线程，解决了多线程编程模型中死锁、状态同步等问题，结合异步 I/O 解决了单线程串行依次执行编程模型因阻塞 I/O 导致资源得不到更优应用的问题。
操作系统对异步 I/O 的支持 非阻塞 I/O 在调用后会立即返回，但是由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅时调用状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作即轮询来确认是否完成。
现有的轮询技术主要有：read select poll epoll kqueue
单线程中实现异步 I/O 总会有各种缺陷，但是利用多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，即可模拟出异步 I/O.
Node 在 linux 下通过自行实现线程池，在 windows 下使用 IOCP(内核管理的线程池)，并且提供 libuv 对平台差异性进行抽象封装，来实现异步 I/O.
Node 如何实现异步 I/O 完成整个异步 I/O 环节的有事件循环、观察者模式、请求对象、I/O 线程池。
事件循环：Node 自身的执行模型。在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们成为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有则取出事件和对应的回调函数。如果存在关联的回调函数，就执行。然后进入下个循环，直到不再有事件处理。
每个事件循环有一个或多个观察者，而判断是否有事件要处理的过程则是向这些观察者询问是否有要处理的事件。
生产者/消费者模型：异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些时间被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</description>
    </item>
    
    <item>
      <title>Node.js 中的 stream</title>
      <link>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</link>
      <pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</guid>
      <description>stream 模块用于构建实现了流接口的对象。Node.js 提供了多种流对象。流可以是可读的、可写的、或者可读可写的。所有的流都是 EventEmitter 的实例。
流的类型：
 Writable 可写入数据的流，如 fs.createWriteStream() Readable 可读取数据的流，如 fs.createReadStream() Duplex 可读又可写的流，如 net.Socket Transform 在读写过程中可以修改或转换数据的 Duplex 流，如 zlib.createDeflate()  Node.js 创建的流都是运行在字符串和 Buffer (或 Uint8Array) 上。流的实现也可以使用其他类型的 JavaScript 值（除了 null）。
使用 stream 实现的 http 服务器:
import http from &amp;#34;http&amp;#34;; const server = http.createServer(function (req, res) { // req 是一个 http.IncomingMessage 实例，是可读流  // res 是一个 http.ServerResponse 实例，是可写流  let body = &amp;#34;&amp;#34;; // 接收数据为 utf8 字符串  // 如果没有设置字符编码，则会接收到 Buffer 对象  req.</description>
    </item>
    
  </channel>
</rss>
