<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on That&#39;s the Way It Is</title>
    <link>https://yrjkqq.github.io/posts/tags/javascript/</link>
    <description>Recent content in JavaScript on That&#39;s the Way It Is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© yrjkqq</copyright>
    <lastBuildDate>Sat, 08 Sep 2018 19:41:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ES2015 标准化的 promise</title>
      <link>https://yrjkqq.github.io/posts/posts/04-promise/</link>
      <pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/04-promise/</guid>
      <description>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
Promise 新建后就会立即执行。
Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。如果调用 resolve 和 reject 时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数可以是正常值，也可以是另一个 Promise 实例。
调用 resolve 函数后面的代码也会执行，并且会先于 Promise 实例的 then 回调函数执行。因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
new Promise((resolve, reject) =&amp;gt; { resolve(1); console.log(2); }).then(r =&amp;gt; { console.log(r); }); // 2 // 1 then 方法指定的回调函数在运行中抛出错误，也会被气候的 catch() 方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
最佳实践：不要在 then() 方法定义 Reject 状态的回调函数，总是使用 catch 方法。
如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，Promise 会吃掉错误。 在服务端可以使用 process.</description>
    </item>
    
    <item>
      <title>JavaScript 的执行上下文和执行栈</title>
      <link>https://yrjkqq.github.io/posts/posts/03-execution-context/</link>
      <pubDate>Fri, 08 Sep 2017 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/03-execution-context/</guid>
      <description>参考
Understanding Execution Context and Execution Stack in Javascript
JavaScript深入之词法作用域和动态作用域
 执行上下文是指解释和执行 JavaScript 代码的环境的抽象概念。有以下三种类型：
  全局执行上下文
未在函数中执行的代码都运行全局执行上下文中，一个程序中只能有一个全局执行上下文。创建 window 对象（浏览器中），将 this 指向 window 对象。
  函数执行上下文
每当函数被调用时，就会为该函数创建一个执行上下文。
  eval 执行上下文
  执行栈是一个拥有后进先出结构的栈，用于保存代码执行过程中的执行上下文。
当 JavaScript 引擎开始解析脚本时，会首先创建全局执行上下文，并将其推入当前执行栈。后续每次遇到函数调用时，都会为其创建一个函数执行上下文，并将其推入执行栈栈顶。JavaScript 引擎首先会执行栈顶的函数，执行完该函数出栈，然后继续栈顶函数，直到全局执行上下文。
如何创建执行上下文？ 分为以下两个阶段：
1. 创建阶段 创建阶段发生了以下两件事：
 创建词法环境 创建变量环境  概念上可以表示为：
ExecutionContext = { LexicalEnvironment = &amp;lt;ref. to LexicalEnvironment in memory&amp;gt;, VariableEnvironment = &amp;lt;ref. to VariableEnvironment in memory&amp;gt;, } 词法环境 ES6 中定义：</description>
    </item>
    
  </channel>
</rss>
