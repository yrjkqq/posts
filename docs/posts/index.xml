<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on That&#39;s the Way It Is</title>
    <link>https://yrjkqq.github.io/posts/posts/</link>
    <description>Recent content in Posts on That&#39;s the Way It Is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© yrjkqq</copyright>
    <lastBuildDate>Tue, 12 May 2020 09:45:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Next.js 源码阅读</title>
      <link>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</link>
      <pubDate>Tue, 12 May 2020 09:45:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</guid>
      <description>前言 Next.js 官方文档不是很详细，一些细节部分需要深入到源码中，才能知其所以然。按照官方贡献指南 Fork 项目到自己的仓库，然后 clone 下来。以最新的 canary 分支版本 10.0.1-canary.4 为基础。
项目结构 深入到源码之前，先摸清楚整个项目的结构。
源码中使用 lerna 在 packages 目录下放置了多个包，每个包有自己的 package.json 文件。使用类似 learn run command 的命令时，会同时运行 packages 目录所有包中可以运行该 command 的命令。
目录结构：
 .vscode 目录下放置了 vscode 相关的配置文件。 bench 目录放置了运行 benchmarks 的代码和文档。 docs 目录下是官方文档。 errors 目录下使用了 Next.js 过程中可能会遇到的错误，记录了错误发生的原因和解决方法。 examples 目录下放置了 Next.js 的用法，或是与各种第三方库或框架结合使用的样例代码 packages 源代码目录，后面主要是阅读这里面的代码 test 测试代码和测试用例  其他比较重要的文件：
 .eslintrc.json ESLint 的配置文件 .prettierrc.json Prettier 的配置文件 jest.config.js 测试框架 jest 的配置文件 lerna.json lerna 的配置文件 package.json 包描述文件，记录了所有可以运行的脚本  阅读前准备 按照官方贡献指南，安装完依赖后，运行 node --inspect packages/next/dist/bin/next dev test/integration/basic 没有报错，然后打开 http://localhost:3000/about 查看页面正常，就安装运行完成。</description>
    </item>
    
    <item>
      <title>《深入浅出 Node.js》学习笔记</title>
      <link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply/</link>
      <pubDate>Wed, 02 Jan 2019 16:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply/</guid>
      <description>第 3 章 异步 I/O 异步 I/O 主要关注点在用户体验和资源分配。
用户体验方面，异步方式在响应请求方面显著降低了同步请求的等待时间，由 M+N 降低为 max(M+N)。
Node 利用单线程，解决了多线程编程模型中死锁、状态同步等问题，结合异步 I/O 解决了单线程串行依次执行编程模型因阻塞 I/O 导致资源得不到更优应用的问题。
操作系统对异步 I/O 的支持 非阻塞 I/O 在调用后会立即返回，但是由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅时调用状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作即轮询来确认是否完成。
现有的轮询技术主要有：read select poll epoll kqueue
单线程中实现异步 I/O 总会有各种缺陷，但是利用多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，即可模拟出异步 I/O.
Node 在 linux 下通过自行实现线程池，在 windows 下使用 IOCP(内核管理的线程池)，并且提供 libuv 对平台差异性进行抽象封装，来实现异步 I/O.
Node 如何实现异步 I/O 完成整个异步 I/O 环节的有事件循环、观察者模式、请求对象、I/O 线程池。
事件循环：Node 自身的执行模型。在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们成为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有则取出事件和对应的回调函数。如果存在关联的回调函数，就执行。然后进入下个循环，直到不再有事件处理。
每个事件循环有一个或多个观察者，而判断是否有事件要处理的过程则是向这些观察者询问是否有要处理的事件。
生产者/消费者模型：异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些时间被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</description>
    </item>
    
    <item>
      <title>极客时间《数据结构与算法之美》学习笔记</title>
      <link>https://yrjkqq.github.io/posts/posts/01-geekbang-algs-beauty/</link>
      <pubDate>Mon, 08 Oct 2018 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/01-geekbang-algs-beauty/</guid>
      <description>为什么要学习算法？建立时空复杂度意识、写出高性能的代码，能够设计基础架构，提升编程技能，训练逻辑思维。
 数据结构就是一组数据的存储方式，而算法则是操作数据的一组方法，比如队列、栈、堆、二分查找、动态规划等。
算法学习重点：
 来历 自身的特点 适合解决的问题 实际的应用场景  复杂度分析 复杂度分析不依赖具体的测试数据来测试，可以粗略统计执行效率，排除测试数据规模和测试环境对结果的影响。
大 O 复杂度表示法 所有代码的执行时间 T(n) 与每行代码的执行次数成正比。
大 O 时间复杂度表示法：T(n) = O(f(n))，并不表示真正的执行时间，而是表示代码执行时间对数据规模增长的变化趋势，也叫做渐进时间复杂度。公式中的低阶、常量、系数并不影响增长趋势，可以忽略，只记录最大量级即可，如 T(n) = O(n^2)。
时间复杂度分析：
 只关注执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度，如果两段代码的量级相当，则加法法则不适用 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积  非多项式量级的算法问题叫做 NP 问题（ O(2^n) 和 O(n!) ），是非常低效的算法。
空间复杂度：表示算法的存储空间与数据规模之间的增长关系。
常见时间复杂度 同一段代码，在不同的输入情况下，复杂度量级有可能是不一样的。
  最好、最坏情况时间复杂度
最理想情况下或最糟糕的情况下，执行一段代码的时间复杂度。
  平均情况时间复杂度
可以简单使用每种情况下执行次数综合除以情况总数来计算得出，但是需要考虑到每种情况出现的概率，即加权平均时间复杂度或者期望时间复杂度。需要用到概率知识
  均摊时间复杂度
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
  数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
如何实现根据下标随机访问数组元素？计算机会给每个内存单元分配一个地址，然后通过地址来访问内存中的数据。需要随机访问数组中的某个元素时，通过下面的寻址公式，计算出元素的内存地址：
a[i]_address = base_address + i * data_type_size 数组和链表的区别：链表适合插入、删除，时间复杂度 O(1); 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)，而查找的时间复杂度并不为 O(1), 即使是有序数组通过二分查找，时间复杂度也是 O(logn).</description>
    </item>
    
    <item>
      <title>ES2015 标准化的 promise</title>
      <link>https://yrjkqq.github.io/posts/posts/04-promise/</link>
      <pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/04-promise/</guid>
      <description>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
Promise 新建后就会立即执行。
Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。如果调用 resolve 和 reject 时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数可以是正常值，也可以是另一个 Promise 实例。
调用 resolve 函数后面的代码也会执行，并且会先于 Promise 实例的 then 回调函数执行。因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
new Promise((resolve, reject) =&amp;gt; { resolve(1); console.log(2); }).then(r =&amp;gt; { console.log(r); }); // 2 // 1 then 方法指定的回调函数在运行中抛出错误，也会被气候的 catch() 方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
最佳实践：不要在 then() 方法定义 Reject 状态的回调函数，总是使用 catch 方法。
如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，Promise 会吃掉错误。 在服务端可以使用 process.</description>
    </item>
    
    <item>
      <title>基础数学知识</title>
      <link>https://yrjkqq.github.io/posts/posts/02-basic-mathmaticth/</link>
      <pubDate>Sun, 08 Oct 2017 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/02-basic-mathmaticth/</guid>
      <description>概率相关 独立事件
代数 对数中换底公式用于计算对数时间复杂度。</description>
    </item>
    
    <item>
      <title>JavaScript 的执行上下文和执行栈</title>
      <link>https://yrjkqq.github.io/posts/posts/03-execution-context/</link>
      <pubDate>Fri, 08 Sep 2017 19:41:00 +0800</pubDate>
      
      <guid>https://yrjkqq.github.io/posts/posts/03-execution-context/</guid>
      <description>参考
Understanding Execution Context and Execution Stack in Javascript
JavaScript深入之词法作用域和动态作用域
 执行上下文是指解释和执行 JavaScript 代码的环境的抽象概念。有以下三种类型：
  全局执行上下文
未在函数中执行的代码都运行全局执行上下文中，一个程序中只能有一个全局执行上下文。创建 window 对象（浏览器中），将 this 指向 window 对象。
  函数执行上下文
每当函数被调用时，就会为该函数创建一个执行上下文。
  eval 执行上下文
  执行栈是一个拥有后进先出结构的栈，用于保存代码执行过程中的执行上下文。
当 JavaScript 引擎开始解析脚本时，会首先创建全局执行上下文，并将其推入当前执行栈。后续每次遇到函数调用时，都会为其创建一个函数执行上下文，并将其推入执行栈栈顶。JavaScript 引擎首先会执行栈顶的函数，执行完该函数出栈，然后继续栈顶函数，直到全局执行上下文。
如何创建执行上下文？ 分为以下两个阶段：
1. 创建阶段 创建阶段发生了以下两件事：
 创建词法环境 创建变量环境  概念上可以表示为：
ExecutionContext = { LexicalEnvironment = &amp;lt;ref. to LexicalEnvironment in memory&amp;gt;, VariableEnvironment = &amp;lt;ref. to VariableEnvironment in memory&amp;gt;, } 词法环境 ES6 中定义：</description>
    </item>
    
  </channel>
</rss>
