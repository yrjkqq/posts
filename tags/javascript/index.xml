<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on That's the Way It Is</title><link>https://yrjkqq.github.io/posts/tags/javascript/</link><description>Recent content in JavaScript on That's the Way It Is</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© yrjkqq</copyright><lastBuildDate>Thu, 19 Nov 2020 01:50:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>setTimeout 和 setInterval</title><link>https://yrjkqq.github.io/posts/posts/11-setinterval-vs-settimeout/</link><pubDate>Thu, 19 Nov 2020 01:50:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/11-setinterval-vs-settimeout/</guid><description>JavaScript 如何模拟 sleep 的函数效果？
在 es5 中可以使用 while(){} 循环，循环条件为当前时间戳与循环开始前时间戳的的差值，如果小于 sleep 的时间间隔，则继续循环，以此模拟。
而在 es6 中可以借助 async await 的语法更优雅且高效的实现这一效果，代码参考 stack overflow 如下：
function sleep(time) { return new Promise((resolve) =&amp;gt; setTimeout(resolve, time)); } async function wait() { await sleep(2000); console.log(&amp;#34;2 seconds later&amp;#34;) } 有了 sleep 函数之后可以验证 setTimeout 和 setInterval 的具体执行效果。查找资料 Scheduling: setTimeout and setInterval 发现：在使用 setInterval 的过程中，会发现前后两次函数的执行时间间隔（上一次执行完成到下一次调用开始）并不是精确的等于指定的延迟时间，是因为 setInterval 是由 JavaScript 引擎进行调度的，每隔指定的延迟时间就会执行回调函数。引擎会等待回调函数执行完成，然后检查调度器如果时间到了指定的延迟时间，则立即执行下一次调用。而回调函数本身执行需要一定时间，这个时间是计算在指定的延迟时间内的，所以前一次调用结束到下一次调用开始的时间间隔是小于指定的延迟时间的。但是，如果函数执行的时间超过了延迟时间，那么下一次调用会立即开始，这种情况下实际的延迟时间会大于执行的延迟时间。
同时在 setInterval 使用前述的 sleep 函数是没有效果的，代码如下。会依次打印 2 2 5 2 5 &amp;hellip;, 其中一开始连续打印两个 2 后才开始打印 5，由此可见 sleep 实际上还是在上一次调度中，结束后打印 5，而此时第三次调度已经开始了。setInterval 的调度并没有等待 sleep 的完成。推测是由于引擎的调度形式有关，会严格按照指定延迟进行调度，而不会将函数执行时间计算在调度内（前文资料中的说法不准确，下一次调用不会等待上一次回调完成，调度器检测到延迟时间已到则会立即开始下一次），所以如果函数本身执行时间大于延迟时间，那么就会出现上一次调用没完成，下一次已经开始了。如果是在发送请求的场景中，可能会造成服务器无法及时响应而请求还在不断累积的现象，超负载。</description></item><item><title>Next.js 源码阅读</title><link>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</link><pubDate>Tue, 12 May 2020 09:45:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</guid><description>前言 Next.js 官方文档不是很详细，一些细节部分需要深入到源码中，才能知其所以然。按照官方贡献指南 Fork 项目到自己的仓库，然后 clone 下来。以最新的 canary 分支版本 10.0.1-canary.4 为基础。
项目结构 深入到源码之前，先摸清楚整个项目的结构。
源码中使用 lerna 在 packages 目录下放置了多个包，每个包有自己的 package.json 文件。使用类似 learn run command 的命令时，会同时运行 packages 目录所有包中可以运行该 command 的命令。
目录结构：
.vscode 目录下放置了 vscode 相关的配置文件。 bench 目录放置了运行 benchmarks 的代码和文档。 docs 目录下是官方文档。 errors 目录下使用了 Next.js 过程中可能会遇到的错误，记录了错误发生的原因和解决方法。 examples 目录下放置了 Next.js 的用法，或是与各种第三方库或框架结合使用的样例代码 packages 源代码目录，后面主要是阅读这里面的代码 test 测试代码和测试用例 其他比较重要的文件：
.eslintrc.json ESLint 的配置文件 .prettierrc.json Prettier 的配置文件 jest.config.js 测试框架 jest 的配置文件 lerna.json lerna 的配置文件 package.json 包描述文件，记录了所有可以运行的脚本 阅读前准备 按照官方贡献指南，安装完依赖后，运行 node --inspect packages/next/dist/bin/next dev test/integration/basic 没有报错，然后打开 http://localhost:3000/about 查看页面正常，就安装运行完成。</description></item><item><title>ES2015 标准化的 promise</title><link>https://yrjkqq.github.io/posts/posts/04-promise/</link><pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/04-promise/</guid><description>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
Promise 新建后就会立即执行。
Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。如果调用 resolve 和 reject 时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数可以是正常值，也可以是另一个 Promise 实例。
调用 resolve 函数后面的代码也会执行，并且会先于 Promise 实例的 then 回调函数执行。因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
new Promise((resolve, reject) =&amp;gt; { resolve(1); console.log(2); }).then(r =&amp;gt; { console.log(r); }); // 2 // 1 then 方法指定的回调函数在运行中抛出错误，也会被气候的 catch() 方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
最佳实践：不要在 then() 方法定义 Reject 状态的回调函数，总是使用 catch 方法。
如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，Promise 会吃掉错误。 在服务端可以使用 process.</description></item><item><title>JavaScript 的执行上下文和执行栈</title><link>https://yrjkqq.github.io/posts/posts/03-execution-context/</link><pubDate>Fri, 08 Sep 2017 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/03-execution-context/</guid><description>参考
Understanding Execution Context and Execution Stack in Javascript
JavaScript深入之词法作用域和动态作用域
执行上下文是指解释和执行 JavaScript 代码的环境的抽象概念。有以下三种类型：
全局执行上下文
未在函数中执行的代码都运行全局执行上下文中，一个程序中只能有一个全局执行上下文。创建 window 对象（浏览器中），将 this 指向 window 对象。
函数执行上下文
每当函数被调用时，就会为该函数创建一个执行上下文。
eval 执行上下文
执行栈是一个拥有后进先出结构的栈，用于保存代码执行过程中的执行上下文。
当 JavaScript 引擎开始解析脚本时，会首先创建全局执行上下文，并将其推入当前执行栈。后续每次遇到函数调用时，都会为其创建一个函数执行上下文，并将其推入执行栈栈顶。JavaScript 引擎首先会执行栈顶的函数，执行完该函数出栈，然后继续栈顶函数，直到全局执行上下文。
如何创建执行上下文？ 分为以下两个阶段：
1. 创建阶段 创建阶段发生了以下两件事：
创建词法环境 创建变量环境 概念上可以表示为：
ExecutionContext = { LexicalEnvironment = &amp;lt;ref. to LexicalEnvironment in memory&amp;gt;, VariableEnvironment = &amp;lt;ref. to VariableEnvironment in memory&amp;gt;, } 词法环境 ES6 中定义：</description></item></channel></rss>