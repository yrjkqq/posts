<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>That's the Way It Is</title><link>https://yrjkqq.github.io/posts/</link><description>Recent content on That's the Way It Is</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© yrjkqq</copyright><lastBuildDate>Tue, 21 Dec 2021 10:57:00 +0800</lastBuildDate><atom:link href="https://yrjkqq.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Babel 究竟用来做什么？</title><link>https://yrjkqq.github.io/posts/posts/15-why-babel/</link><pubDate>Tue, 21 Dec 2021 10:57:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/15-why-babel/</guid><description>经过这几年的前端工作，我觉得有必要停下来回顾一下这些年用过的前端工具，一方面是学习这些新工具的新的生机，一方面也是对现有知识的梳理，期望找出自身的不足。
在网上发现一个资源:前端路线图
Babel 是什么？ babel 是一个 JavaScript 编译器，它可以转换语法、为不支持的特性添加腻子脚本、源代码转换。
Babel 解决什么问题？ Babel 可以将浏览器暂不支持的语法通过添加腻子脚本转换为支持的语法，这不仅包括旧浏览器对 es6 的支持也包括最新的浏览器对最新的 es2021 语法的支持，它让我们在写代码时候不需要考虑浏览器支不支持。
Babel 通过插件使用语法转换来支持最新的 JavaScript 语法，而不用等待浏览器的支持。 Babel 能转换 jsx 语法。 Babel 支持 TypeScript 语法，能够自动去掉类型注释。 Babel 默认不带任何插件。可以使用已有的插件或自己写的插件来管道化你的代码转换。 Babel 支持 sourcemap，可以进行 debug. Babel 与最新的 ECMAScript 标准保持一致。为了与标准兼容甚至不惜牺牲性能。 Babel 通过 assumptions(假定) 来去掉一些假定代码中不会使用到的代码腻子脚本来减小体积 babel 怎么使用？ 引入 @babel/polyfill 安装 yarn add @babel/polyfill 后在配置文件中增加 &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot; 来只引入使用到的 polyfill，@babel/polyfill 会自动安装 2.6.12 版本的 core-js
// babel.config.js const presets = [ [ &amp;#34;@babel/preset-env&amp;#34;, { targets: { edge: &amp;#34;17&amp;#34;, firefox: &amp;#34;60&amp;#34;, chrome: &amp;#34;67&amp;#34;, safari: &amp;#34;11.</description></item><item><title>SVG？</title><link>https://yrjkqq.github.io/posts/posts/16-svg/</link><pubDate>Tue, 21 Dec 2021 10:57:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/16-svg/</guid><description>MDN 上非常好的 svg 教程</description></item><item><title>React.isValidElement 如何实现？</title><link>https://yrjkqq.github.io/posts/posts/14-react-is-valid-element-impl/</link><pubDate>Sun, 06 Dec 2020 16:00:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/14-react-is-valid-element-impl/</guid><description>isValidElement 函数从 packages\react\src\ReactElement.js 导出，其中使用到 $$typeof 判断是否是 ReactElement.
/** * Verifies the object is a ReactElement. * See https://reactjs.org/docs/react-api.html#isvalidelement * @param {?object} object * @return {boolean} True if `object` is a ReactElement. * @final */ export function isValidElement(object) { return ( typeof object === &amp;#39;object&amp;#39; &amp;amp;&amp;amp; object !== null &amp;amp;&amp;amp; object.$$typeof === REACT_ELEMENT_TYPE ); } 我们知道，React 中的节点都会使用 React.createElement 创建。createElement 会返回一个 ReactElement
const ReactElement = function(type, key, ref, self, source, owner, props) { const element = { // This tag allows us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // Built-in properties that belong on the element type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element.</description></item><item><title>React build 时为何会要用到 JDK?</title><link>https://yrjkqq.github.io/posts/posts/13-react-with-java-why/</link><pubDate>Sun, 06 Dec 2020 12:00:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/13-react-with-java-why/</guid><description>React 官方贡献指南中提到，运行 React 源代码需要使用到 JDK, 而且在使用 yarn build 时，如果没有安装 JDK 则会报错，这是为什么呢？要 Java 做什么呢？本文将一探究竟。
yarn build 会运行 node ./scripts/rollup/build.js 脚本，运行完会输出: 控制台会打印一个表格，这个表格是不是就是用到 Java 相关的库输出的呢？
这个表格是使用 cli-table 和 chalk 库实现的，与 Java 无关。printResults 方法会获取 table 类型的数据。
// scripts\rollup\build.js async function buildEverything() { // ... console.log(Stats.printResults()); if (!forcePrettyOutput) { Stats.saveResults(); } if (shouldExtractErrors) { console.warn( &amp;#39;\nWarning: this build was created with --extract-errors enabled.\n&amp;#39; + &amp;#39;this will result in extremely slow builds and should only be\n&amp;#39; + &amp;#39;used when the error map needs to be rebuilt.</description></item><item><title>区块链和加密货币是什么？</title><link>https://yrjkqq.github.io/posts/posts/12-blockchain-tour-part1/</link><pubDate>Sun, 22 Nov 2020 18:40:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/12-blockchain-tour-part1/</guid><description>通过 币安学院 的系列文章，来学习区块链和加密货币相关知识。
加密货币中不存在机构。
公钥密码学 借助密码学和高等数学来保护资金的安全。加密货币生态系统中使用的密码学是公钥密码学（PKC）, 又称非对称密码学。RSA 是最常见的非对称加密算法。RSA 中通过两个大质数相乘得到公共模数生成密钥。PKC 的应用：
加密电子邮件 HTTPS 中的安全套接层（SSL）协议 安全电子投票 区块链和加密货币 椭圆曲线数字签名算法（ECDSA）用于比特币和其他加密货币系统，用于确保存储在区块链的上数据的安全性以及验证交易事务。
数字签名适用于验证数字和数据真实性和完整性的加密机制。PKC 可以应用于生成数字签名。本质上，该过程发送方使用自己的私钥对消息（数据）的哈希值进行加密。接下来，消息的接收方可以使用签名者提供的公钥来检查该数字签名是否有效。
比特币区块链使用 PKC 和数字签名，这个过程中没有进行加密。比特币又部署了 ECDSA 来验证交易。
加密货币中，数字签名包含三个基本流程：散列、签名和验证。</description></item><item><title>setTimeout 和 setInterval</title><link>https://yrjkqq.github.io/posts/posts/11-setinterval-vs-settimeout/</link><pubDate>Thu, 19 Nov 2020 01:50:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/11-setinterval-vs-settimeout/</guid><description>JavaScript 如何模拟 sleep 的函数效果？
在 es5 中可以使用 while(){} 循环，循环条件为当前时间戳与循环开始前时间戳的的差值，如果小于 sleep 的时间间隔，则继续循环，以此模拟。
而在 es6 中可以借助 async await 的语法更优雅且高效的实现这一效果，代码参考 stack overflow 如下：
function sleep(time) { return new Promise((resolve) =&amp;gt; setTimeout(resolve, time)); } async function wait() { await sleep(2000); console.log(&amp;#34;2 seconds later&amp;#34;) } 有了 sleep 函数之后可以验证 setTimeout 和 setInterval 的具体执行效果。查找资料 Scheduling: setTimeout and setInterval 发现：在使用 setInterval 的过程中，会发现前后两次函数的执行时间间隔（上一次执行完成到下一次调用开始）并不是精确的等于指定的延迟时间，是因为 setInterval 是由 JavaScript 引擎进行调度的，每隔指定的延迟时间就会执行回调函数。引擎会等待回调函数执行完成，然后检查调度器如果时间到了指定的延迟时间，则立即执行下一次调用。而回调函数本身执行需要一定时间，这个时间是计算在指定的延迟时间内的，所以前一次调用结束到下一次调用开始的时间间隔是小于指定的延迟时间的。但是，如果函数执行的时间超过了延迟时间，那么下一次调用会立即开始，这种情况下实际的延迟时间会大于执行的延迟时间。
同时在 setInterval 使用前述的 sleep 函数是没有效果的，代码如下。会依次打印 2 2 5 2 5 &amp;hellip;, 其中一开始连续打印两个 2 后才开始打印 5，由此可见 sleep 实际上还是在上一次调度中，结束后打印 5，而此时第三次调度已经开始了。setInterval 的调度并没有等待 sleep 的完成。推测是由于引擎的调度形式有关，会严格按照指定延迟进行调度，而不会将函数执行时间计算在调度内（前文资料中的说法不准确，下一次调用不会等待上一次回调完成，调度器检测到延迟时间已到则会立即开始下一次），所以如果函数本身执行时间大于延迟时间，那么就会出现上一次调用没完成，下一次已经开始了。如果是在发送请求的场景中，可能会造成服务器无法及时响应而请求还在不断累积的现象，超负载。</description></item><item><title>React 结合 Immutable 进行性能优化</title><link>https://yrjkqq.github.io/posts/posts/10-performance-optimization-with-immutable/</link><pubDate>Thu, 19 Nov 2020 00:08:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/10-performance-optimization-with-immutable/</guid><description>React 中虽然可以使用 useMemo useCallback React.memo 等 api 进行性能优化，但是如果是复杂场景下的复杂数据的更新，使用 Immutable 是更合适的。
在下面这个例子中:
import * as React from &amp;#34;react&amp;#34;; import &amp;#34;./styles.css&amp;#34;; import { List } from &amp;#34;immutable&amp;#34;; function ListChild({ names }) { const [v, setV] = React.useState(&amp;#34;a&amp;#34;); return ( &amp;lt;div&amp;gt; {Date.now()}-{names.join(&amp;#34;,&amp;#34;)} &amp;lt;input value={v} onChange={(e) =&amp;gt; setV(e.target.value)} /&amp;gt; &amp;lt;/div&amp;gt; ); } const MemoListChild = React.memo(ListChild, (prevProps, nextProps) =&amp;gt; { return prevProps.names.equals(nextProps.names); }); export default function App() { const [value, setValue] = React.useState(&amp;#34;&amp;#34;); const [names, setNames] = React.</description></item><item><title>React Hooks 性能优化</title><link>https://yrjkqq.github.io/posts/posts/08-react-hooks-performance-optimization/</link><pubDate>Fri, 13 Nov 2020 00:35:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/08-react-hooks-performance-optimization/</guid><description>React 16.8.0 引入 Hook 之后，新写的项目中基本上全部采用 Hook 的写法。
Hook 与 Class 相比，主要带来以下几方面的优势：
复杂组件变得难以理解
Class 组件中需要将各个业务代码写在各个生命周期函数中，可能存在同样的功能分布在各个生命周期函数中，代码逻混乱，尤其是在复杂组件中。而 Hook 将组件中相互关联的部分拆分成更小的函数，而非强制按照生命周期划分。 在组件之间复用状态逻辑很难
React 中会使用到 render props 或 高阶组件 来解决逻辑复用的问题，但这些方式需要改变代码结构，例如使用高阶函数后会产生组件嵌套，层次太多就会产生嵌套地狱。而 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用，并且无需修改代码结构。 难以理解的 Class
Class 由于 JavaScript 语言的特殊性，在实现方面没有稳定的提案，相比于函数式组件学习成本更高，例如 this 的使用或者绑定事件函数。同时，Class 组件会使一些新的优化手段无法在 React 实现，例如组件预编译。而且 Class 不能进行很好的压缩。 Hook 可以在使用函数式组件的情况下使用到更多的 React 特性。但是切换到 Hook 之后，就会就会存在之前的一些优化手段需要使用对应的 Hook 写法。
使用 Class 组件时，常见的优化手段：
Component 类组件使用 shouldComponentUpdate 可以根据 shouldComponentUpdate 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。在该方法内部进行对变化前后的 props 和 state 进行比较，返回则会跳过更新，即不会吊桶 render() 和 componentDidUpdate().</description></item><item><title>React Fiber 架构</title><link>https://yrjkqq.github.io/posts/posts/09-react-fiber/</link><pubDate>Thu, 12 Nov 2020 11:12:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/09-react-fiber/</guid><description>Fiber 架构主要是使用了新的 reconciler 调谐器，区别于 React 15 的 stack reconciler 调谐器。
Reconciliation 协调主要是是 Diffing 算法。基于两个前提：
两个不同类型的元素会产生不同的树 开发者可以通过 key prop 来暗示那些子元素在不同的渲染下能保持稳定 启发性算法复杂度由之前的 O(n^3) 将低到 O(n)。
不同类型的元素：根节点不通，直接会卸载原来的树并构建新的树。
对比同一类型的 DOM 元素：保留 DOM 节点，仅比对及更新有改变的属性。
同一类型的组件元素：当一个组件更新时，组件实例保持不变，state 在跨越不同的渲染时保持一致。React 将更新组件实例的 props 以跟最新的元素保持一致，并调用 componentWillUpdate 方法。
下一步调用 render 方法，diff 算法将在之前的结果以及新的结果中进行递归。
key 属性，React 使用 key 属性来匹配原有树上的子元素和最新树上的子元素，匹配到则检测更新，否则就新增结点或删除。没有 key 则会对整个节点树进行比较。
满足假设：
类似的组件应该封装成同一类型，有利于 React 进行匹配 key 保持稳定并唯一。</description></item><item><title>URL 模块和 querystring 模块</title><link>https://yrjkqq.github.io/posts/posts/07-url-urlsearchparams-querystring/</link><pubDate>Thu, 05 Nov 2020 15:30:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/07-url-urlsearchparams-querystring/</guid><description>url 模块提供了解析 URL 的工具。const url = require('url')
url 模块提供了两套 API:
legacy API, Node.js 特有 WHATWG URL Standard, 用于 web 浏览器 // WHATWG API const myURL = new URL(&amp;#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&amp;#39;); /** &amp;gt; myURL URL { href: &amp;#39;https://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash&amp;#39;, origin: &amp;#39;https://sub.example.com:8080&amp;#39;, protocol: &amp;#39;https:&amp;#39;, username: &amp;#39;user&amp;#39;, password: &amp;#39;pass&amp;#39;, host: &amp;#39;sub.example.com:8080&amp;#39;, hostname: &amp;#39;sub.example.com&amp;#39;, port: &amp;#39;8080&amp;#39;, pathname: &amp;#39;/p/a/t/h&amp;#39;, search: &amp;#39;?query=string&amp;#39;, searchParams: URLSearchParams { &amp;#39;query&amp;#39; =&amp;gt; &amp;#39;string&amp;#39; }, hash: &amp;#39;#hash&amp;#39; } */ // Legacy API const url = require(&amp;#39;url&amp;#39;); const myURL = url.</description></item><item><title>Next.js 源码阅读</title><link>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</link><pubDate>Tue, 12 May 2020 09:45:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/05-nextjs-srouce-code/</guid><description>前言 Next.js 官方文档不是很详细，一些细节部分需要深入到源码中，才能知其所以然。按照官方贡献指南 Fork 项目到自己的仓库，然后 clone 下来。以最新的 canary 分支版本 10.0.1-canary.4 为基础。
项目结构 深入到源码之前，先摸清楚整个项目的结构。
源码中使用 lerna 在 packages 目录下放置了多个包，每个包有自己的 package.json 文件。使用类似 learn run command 的命令时，会同时运行 packages 目录所有包中可以运行该 command 的命令。
目录结构：
.vscode 目录下放置了 vscode 相关的配置文件。 bench 目录放置了运行 benchmarks 的代码和文档。 docs 目录下是官方文档。 errors 目录下使用了 Next.js 过程中可能会遇到的错误，记录了错误发生的原因和解决方法。 examples 目录下放置了 Next.js 的用法，或是与各种第三方库或框架结合使用的样例代码 packages 源代码目录，后面主要是阅读这里面的代码 test 测试代码和测试用例 其他比较重要的文件：
.eslintrc.json ESLint 的配置文件 .prettierrc.json Prettier 的配置文件 jest.config.js 测试框架 jest 的配置文件 lerna.json lerna 的配置文件 package.json 包描述文件，记录了所有可以运行的脚本 阅读前准备 按照官方贡献指南，安装完依赖后，运行 node --inspect packages/next/dist/bin/next dev test/integration/basic 没有报错，然后打开 http://localhost:3000/about 查看页面正常，就安装运行完成。</description></item><item><title>《深入浅出 Node.js》学习笔记 Part4</title><link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part4/</link><pubDate>Fri, 18 Jan 2019 21:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part4/</guid><description>第 10 章 测试 略。
第 11 章 产品化 项目工程化：
目录结构 Project Structure Practices 构建工具 Grunt 编码规范 ESLint 代码审查 部署流程
性能：
动静分离：Nginx CDN 启用缓存：Redis 多进程架构：官方 process_child cluster 模块，社区的 pm2 模块进行进程管理 读写分离：数据库读写分离 日志：
winston 库 监控报警：
日志监控 响应时间 进程监控 磁盘监控 内存监控 CPU 占用监控 CPU load 监控 I/O 负载 网络监控 应用状态监控 DNS 监控 报警：
邮件报警：nodemailer 模块发送邮件 短信或电话报警 稳定性： 多进程、多机器、多机房，分布式设计。 容灾备份
异构共存： 协议</description></item><item><title>Node.js 的 child_process, cluster, worker_threads 模块</title><link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part3/</link><pubDate>Mon, 14 Jan 2019 16:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part3/</guid><description>Node 并非真正的单线程架构，有一些 I/O 线程由底层 libuv 处理。JavaScript 代码永远运行在 V8 上，是单线程的。
多线程中，每个线程都拥有自己独立的堆栈，这个堆栈需要占用一定的内存空间。由于一个 CPU 核心在一个时刻只能做一件事情，操作系统只能通过将 CPU 切分为时间片的方法，让线程可以较为均匀地使用 CPU 资源。但是操作系统在切换线程的同时也要切换线程的上下文，当线程数量过多时，事件会被消耗到上下文切换中。Node 基于事件驱动，采用单线程避免了不必要的内存开销和上下文切换开销。
Node 中所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，但它不受多进程或多线程中资源上限的影响，可伸缩性远比前两者更高。也就是说，CPU 计算能力可以通过增加 CPU 核心的数量来进行提高，进一步提高 Node 的性能。那么 Node 中如何利用多核 CPU 呢？
如何提高 CPU 的利用率？ 解决单线程单进程堆多核使用不足的问题：理想状态下每个进程各自利用一个 CPU, 以此实现多核 CPU 的利用。Node 提供了 child_process 模块。
Master-Worker 主从模式：分布式架构中用于并行处理业务的模式。主进程不负责具体的业务处理，而是负责调度和管理工作进程，趋于稳定。工作进程负责具体的业务处理，需要关注其稳定性。示例代码如下：
// master.js import childProcess from &amp;#34;child_process&amp;#34;; import os from &amp;#34;os&amp;#34;; import { dirname } from &amp;#34;path&amp;#34;; import { fileURLToPath } from &amp;#34;url&amp;#34;; const __filename = fileURLToPath(import.meta.url); const __dirname = dirname(__filename); // 获取操作系统的 cpu 的核心数 const cpus = os.</description></item><item><title>《深入浅出 Node.js》学习笔记 Part2</title><link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</link><pubDate>Wed, 09 Jan 2019 16:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part2/</guid><description>第 6 章 理解 Buffer 在 Node 中，应用需要处理网络协议、操作数据库、处理图片、接受文件上传等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript 自有的字符串远远不能满足这些需求，于是有了 Buffer.
Buffer 结构 Buffer 类似于 Array, 但主要用于操作字节。Buffer 是一个由 JavaScript 和 C++ 结合的模块，C++ 实现性能相关的部分。Buffer 所占用的内存不通过 V8 分配，属于堆外内存，有更高效和专用的内存分配策略。Buffer 位于全局对象 global 上，无需导入。
Buffer 内存分配：在 C++ 层面申请内存，在 JavaScript 上分配内存。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和时候分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。大块的 Buffer 直接调用 C++ 层面提供的内存。
Buffer 的转换 字符串 -&amp;gt; Buffer 对象：Buffer.from(string[, encoding]) encoding 默认为 &amp;lsquo;utf8&amp;rsquo;. 一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法实现。
Buffer 对象 -&amp;gt; 字符串：buf.toString([encoding[, start[, end]]])
Buffer 支持的编码类型：Buffer 与字符编码
字符编码：utf8 utf16le latin1 二进制转文本的编码：base64 hex 传统的字符串编码：ascii binary ucs2 Buffer 的拼接 从常见的输入流从读取内容的示例代码：</description></item><item><title>《深入浅出 Node.js》学习笔记 Part1</title><link>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</link><pubDate>Wed, 02 Jan 2019 16:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/00-understanding-nodejs-deeply-part1/</guid><description>第 3 章 异步 I/O 异步 I/O 主要关注点在用户体验和资源分配。
用户体验方面，异步方式在响应请求方面显著降低了同步请求的等待时间，由 M+N 降低为 max(M+N)。
Node 利用单线程，解决了多线程编程模型中死锁、状态同步等问题，结合异步 I/O 解决了单线程串行依次执行编程模型因阻塞 I/O 导致资源得不到更优应用的问题。
操作系统对异步 I/O 的支持 非阻塞 I/O 在调用后会立即返回，但是由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅时调用状态。为了获取完整的数据，应用程序需要重复调用 I/O 操作即轮询来确认是否完成。
现有的轮询技术主要有：read select poll epoll kqueue
单线程中实现异步 I/O 总会有各种缺陷，但是利用多线程，通过让部分线程进行阻塞 I/O 或者非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递，即可模拟出异步 I/O.
Node 在 linux 下通过自行实现线程池，在 windows 下使用 IOCP(内核管理的线程池)，并且提供 libuv 对平台差异性进行抽象封装，来实现异步 I/O.
Node 如何实现异步 I/O 完成整个异步 I/O 环节的有事件循环、观察者模式、请求对象、I/O 线程池。
事件循环：Node 自身的执行模型。在进程启动时，Node 便会创建一个类似于 while(true) 的循环，每执行一次循环体的过程我们成为 Tick。每个 Tick 的过程就是查看是否有事件等待处理，如果有则取出事件和对应的回调函数。如果存在关联的回调函数，就执行。然后进入下个循环，直到不再有事件处理。
每个事件循环有一个或多个观察者，而判断是否有事件要处理的过程则是向这些观察者询问是否有要处理的事件。
生产者/消费者模型：异步 I/O、网络请求等则是事件的生产者，为 Node 提供不同类型的事件，这些时间被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</description></item><item><title>极客时间《数据结构与算法之美》学习笔记</title><link>https://yrjkqq.github.io/posts/posts/01-geekbang-algs-beauty/</link><pubDate>Mon, 08 Oct 2018 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/01-geekbang-algs-beauty/</guid><description>为什么要学习算法？建立时空复杂度意识、写出高性能的代码，能够设计基础架构，提升编程技能，训练逻辑思维。
数据结构就是一组数据的存储方式，而算法则是操作数据的一组方法，比如队列、栈、堆、二分查找、动态规划等。
算法学习重点：
来历 自身的特点 适合解决的问题 实际的应用场景 复杂度分析 复杂度分析不依赖具体的测试数据来测试，可以粗略统计执行效率，排除测试数据规模和测试环境对结果的影响。
大 O 复杂度表示法 所有代码的执行时间 T(n) 与每行代码的执行次数成正比。
大 O 时间复杂度表示法：T(n) = O(f(n))，并不表示真正的执行时间，而是表示代码执行时间对数据规模增长的变化趋势，也叫做渐进时间复杂度。公式中的低阶、常量、系数并不影响增长趋势，可以忽略，只记录最大量级即可，如 T(n) = O(n^2)。
时间复杂度分析：
只关注执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度，如果两段代码的量级相当，则加法法则不适用 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 非多项式量级的算法问题叫做 NP 问题（ O(2^n) 和 O(n!) ），是非常低效的算法。
空间复杂度：表示算法的存储空间与数据规模之间的增长关系。
常见时间复杂度 同一段代码，在不同的输入情况下，复杂度量级有可能是不一样的。
最好、最坏情况时间复杂度
最理想情况下或最糟糕的情况下，执行一段代码的时间复杂度。
平均情况时间复杂度
可以简单使用每种情况下执行次数综合除以情况总数来计算得出，但是需要考虑到每种情况出现的概率，即加权平均时间复杂度或者期望时间复杂度。需要用到概率知识
均摊时间复杂度
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。
数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
如何实现根据下标随机访问数组元素？计算机会给每个内存单元分配一个地址，然后通过地址来访问内存中的数据。需要随机访问数组中的某个元素时，通过下面的寻址公式，计算出元素的内存地址：
a[i]_address = base_address + i * data_type_size 数组和链表的区别：链表适合插入、删除，时间复杂度 O(1); 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)，而查找的时间复杂度并不为 O(1), 即使是有序数组通过二分查找，时间复杂度也是 O(logn).</description></item><item><title>ES2015 标准化的 promise</title><link>https://yrjkqq.github.io/posts/posts/04-promise/</link><pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/04-promise/</guid><description>ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。
Promise 新建后就会立即执行。
Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。如果调用 resolve 和 reject 时带有参数，那么它们的参数会被传递给回调函数。reject 函数的参数通常是 Error 对象的实例，表示抛出的错误；resolve 函数的参数可以是正常值，也可以是另一个 Promise 实例。
调用 resolve 函数后面的代码也会执行，并且会先于 Promise 实例的 then 回调函数执行。因为立即 resolve 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
new Promise((resolve, reject) =&amp;gt; { resolve(1); console.log(2); }).then(r =&amp;gt; { console.log(r); }); // 2 // 1 then 方法指定的回调函数在运行中抛出错误，也会被气候的 catch() 方法捕获。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。
最佳实践：不要在 then() 方法定义 Reject 状态的回调函数，总是使用 catch 方法。
如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。Promise 内部的错误不会影响到 Promise 外部的代码，Promise 会吃掉错误。 在服务端可以使用 process.</description></item><item><title>Node.js 中的 stream</title><link>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</link><pubDate>Sat, 08 Sep 2018 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/06-nodejs-stream/</guid><description>stream 模块用于构建实现了流接口的对象。Node.js 提供了多种流对象。流可以是可读的、可写的、或者可读可写的。所有的流都是 EventEmitter 的实例。
流的类型：
Writable 可写入数据的流，如 fs.createWriteStream() Readable 可读取数据的流，如 fs.createReadStream() Duplex 可读又可写的流，如 net.Socket Transform 在读写过程中可以修改或转换数据的 Duplex 流，如 zlib.createDeflate() Node.js 创建的流都是运行在字符串和 Buffer (或 Uint8Array) 上。流的实现也可以使用其他类型的 JavaScript 值（除了 null）。
使用 stream 实现的 http 服务器:
import http from &amp;#34;http&amp;#34;; const server = http.createServer(function (req, res) { // req 是一个 http.IncomingMessage 实例，是可读流 // res 是一个 http.ServerResponse 实例，是可写流 let body = &amp;#34;&amp;#34;; // 接收数据为 utf8 字符串 // 如果没有设置字符编码，则会接收到 Buffer 对象 req.</description></item><item><title>基础数学知识</title><link>https://yrjkqq.github.io/posts/posts/02-basic-mathmaticth/</link><pubDate>Sun, 08 Oct 2017 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/02-basic-mathmaticth/</guid><description>概率相关 独立事件
代数 对数中换底公式用于计算对数时间复杂度。</description></item><item><title>JavaScript 的执行上下文和执行栈</title><link>https://yrjkqq.github.io/posts/posts/03-execution-context/</link><pubDate>Fri, 08 Sep 2017 19:41:00 +0800</pubDate><guid>https://yrjkqq.github.io/posts/posts/03-execution-context/</guid><description>参考
Understanding Execution Context and Execution Stack in Javascript
JavaScript深入之词法作用域和动态作用域
执行上下文是指解释和执行 JavaScript 代码的环境的抽象概念。有以下三种类型：
全局执行上下文
未在函数中执行的代码都运行全局执行上下文中，一个程序中只能有一个全局执行上下文。创建 window 对象（浏览器中），将 this 指向 window 对象。
函数执行上下文
每当函数被调用时，就会为该函数创建一个执行上下文。
eval 执行上下文
执行栈是一个拥有后进先出结构的栈，用于保存代码执行过程中的执行上下文。
当 JavaScript 引擎开始解析脚本时，会首先创建全局执行上下文，并将其推入当前执行栈。后续每次遇到函数调用时，都会为其创建一个函数执行上下文，并将其推入执行栈栈顶。JavaScript 引擎首先会执行栈顶的函数，执行完该函数出栈，然后继续栈顶函数，直到全局执行上下文。
如何创建执行上下文？ 分为以下两个阶段：
1. 创建阶段 创建阶段发生了以下两件事：
创建词法环境 创建变量环境 概念上可以表示为：
ExecutionContext = { LexicalEnvironment = &amp;lt;ref. to LexicalEnvironment in memory&amp;gt;, VariableEnvironment = &amp;lt;ref. to VariableEnvironment in memory&amp;gt;, } 词法环境 ES6 中定义：</description></item></channel></rss>